// go:build !ignoreWeaverGen

package benchmarks

// Code generated by "weaver generate". DO NOT EDIT.
import (
	"context"
	"errors"
	"fmt"
	"github.com/ServiceWeaver/weaver"
	"github.com/ServiceWeaver/weaver/runtime/codegen"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"reflect"
	"time"
)
var _ codegen.LatestVersion = codegen.Version[[0][10]struct{}]("You used 'weaver generate' codegen version 0.10.0, but you built your code with an incompatible weaver module version. Try upgrading 'weaver generate' and re-running it.")

func init() {
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping1",
		Iface:       reflect.TypeOf((*Ping1)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping1{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping1_local_stub{impl: impl.(Ping1), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping1_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping1", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping1", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping1_server_stub{impl: impl.(Ping1), addLoad: addLoad}
		},
		RefData: "⟦544443c5:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping1→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping2⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping10",
		Iface:       reflect.TypeOf((*Ping10)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping10{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping10_local_stub{impl: impl.(Ping10), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping10_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping10", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping10", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping10_server_stub{impl: impl.(Ping10), addLoad: addLoad}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping2",
		Iface:       reflect.TypeOf((*Ping2)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping2{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping2_local_stub{impl: impl.(Ping2), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping2_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping2", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping2", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping2_server_stub{impl: impl.(Ping2), addLoad: addLoad}
		},
		RefData: "⟦b42b173c:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping2→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping3⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping3",
		Iface:       reflect.TypeOf((*Ping3)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping3{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping3_local_stub{impl: impl.(Ping3), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping3_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping3", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping3", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping3_server_stub{impl: impl.(Ping3), addLoad: addLoad}
		},
		RefData: "⟦8c498b47:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping3→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping4⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping4",
		Iface:       reflect.TypeOf((*Ping4)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping4{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping4_local_stub{impl: impl.(Ping4), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping4_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping4", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping4", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping4_server_stub{impl: impl.(Ping4), addLoad: addLoad}
		},
		RefData: "⟦90669915:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping4→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping5⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping5",
		Iface:       reflect.TypeOf((*Ping5)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping5{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping5_local_stub{impl: impl.(Ping5), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping5_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping5", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping5", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping5_server_stub{impl: impl.(Ping5), addLoad: addLoad}
		},
		RefData: "⟦a38d1914:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping5→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping6⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping6",
		Iface:       reflect.TypeOf((*Ping6)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping6{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping6_local_stub{impl: impl.(Ping6), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping6_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping6", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping6", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping6_server_stub{impl: impl.(Ping6), addLoad: addLoad}
		},
		RefData: "⟦ebf8b6d3:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping6→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping7⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping7",
		Iface:       reflect.TypeOf((*Ping7)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping7{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping7_local_stub{impl: impl.(Ping7), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping7_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping7", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping7", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping7_server_stub{impl: impl.(Ping7), addLoad: addLoad}
		},
		RefData: "⟦88d68418:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping7→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping8⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping8",
		Iface:       reflect.TypeOf((*Ping8)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping8{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping8_local_stub{impl: impl.(Ping8), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping8_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping8", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping8", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping8_server_stub{impl: impl.(Ping8), addLoad: addLoad}
		},
		RefData: "⟦ed98271d:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping8→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping9⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:        "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping9",
		Iface:       reflect.TypeOf((*Ping9)(nil)).Elem(),
		Impl:        reflect.TypeOf(ping9{}),
		LocalStubFn: func(impl any, tracer trace.Tracer) any { return ping9_local_stub{impl: impl.(Ping9), tracer: tracer} },
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return ping9_client_stub{stub: stub, pingCMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping9", Method: "PingC"}), pingSMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "github.com/ServiceWeaver/weaver/internal/benchmarks/Ping9", Method: "PingS"})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return ping9_server_stub{impl: impl.(Ping9), addLoad: addLoad}
		},
		RefData: "⟦5ceb96a7:wEaVeReDgE:github.com/ServiceWeaver/weaver/internal/benchmarks/Ping9→github.com/ServiceWeaver/weaver/internal/benchmarks/Ping10⟧\n",
	})
}

// weaver.Instance checks.
var _ weaver.InstanceOf[Ping1] = &ping1{}
var _ weaver.InstanceOf[Ping10] = &ping10{}
var _ weaver.InstanceOf[Ping2] = &ping2{}
var _ weaver.InstanceOf[Ping3] = &ping3{}
var _ weaver.InstanceOf[Ping4] = &ping4{}
var _ weaver.InstanceOf[Ping5] = &ping5{}
var _ weaver.InstanceOf[Ping6] = &ping6{}
var _ weaver.InstanceOf[Ping7] = &ping7{}
var _ weaver.InstanceOf[Ping8] = &ping8{}
var _ weaver.InstanceOf[Ping9] = &ping9{}

// weaver.Router checks.
var _ weaver.Unrouted = &ping1{}
var _ weaver.Unrouted = &ping10{}
var _ weaver.Unrouted = &ping2{}
var _ weaver.Unrouted = &ping3{}
var _ weaver.Unrouted = &ping4{}
var _ weaver.Unrouted = &ping5{}
var _ weaver.Unrouted = &ping6{}
var _ weaver.Unrouted = &ping7{}
var _ weaver.Unrouted = &ping8{}
var _ weaver.Unrouted = &ping9{}

// Local stub implementations.

type ping1_local_stub struct {
	impl   Ping1
	tracer trace.Tracer
}

// Check that ping1_local_stub implements the Ping1 interface.
var _ Ping1 = &ping1_local_stub{}

func (s ping1_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping1.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping1_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping1.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping10_local_stub struct {
	impl   Ping10
	tracer trace.Tracer
}

// Check that ping10_local_stub implements the Ping10 interface.
var _ Ping10 = &ping10_local_stub{}

func (s ping10_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping10.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping10_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping10.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping2_local_stub struct {
	impl   Ping2
	tracer trace.Tracer
}

// Check that ping2_local_stub implements the Ping2 interface.
var _ Ping2 = &ping2_local_stub{}

func (s ping2_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping2.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping2_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping2.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping3_local_stub struct {
	impl   Ping3
	tracer trace.Tracer
}

// Check that ping3_local_stub implements the Ping3 interface.
var _ Ping3 = &ping3_local_stub{}

func (s ping3_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping3.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping3_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping3.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping4_local_stub struct {
	impl   Ping4
	tracer trace.Tracer
}

// Check that ping4_local_stub implements the Ping4 interface.
var _ Ping4 = &ping4_local_stub{}

func (s ping4_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping4.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping4_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping4.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping5_local_stub struct {
	impl   Ping5
	tracer trace.Tracer
}

// Check that ping5_local_stub implements the Ping5 interface.
var _ Ping5 = &ping5_local_stub{}

func (s ping5_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping5.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping5_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping5.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping6_local_stub struct {
	impl   Ping6
	tracer trace.Tracer
}

// Check that ping6_local_stub implements the Ping6 interface.
var _ Ping6 = &ping6_local_stub{}

func (s ping6_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping6.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping6_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping6.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping7_local_stub struct {
	impl   Ping7
	tracer trace.Tracer
}

// Check that ping7_local_stub implements the Ping7 interface.
var _ Ping7 = &ping7_local_stub{}

func (s ping7_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping7.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping7_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping7.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping8_local_stub struct {
	impl   Ping8
	tracer trace.Tracer
}

// Check that ping8_local_stub implements the Ping8 interface.
var _ Ping8 = &ping8_local_stub{}

func (s ping8_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping8.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping8_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping8.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

type ping9_local_stub struct {
	impl   Ping9
	tracer trace.Tracer
}

// Check that ping9_local_stub implements the Ping9 interface.
var _ Ping9 = &ping9_local_stub{}

func (s ping9_local_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping9.PingC", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingC(ctx, a0, a1)
}

func (s ping9_local_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "benchmarks.Ping9.PingS", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PingS(ctx, a0, a1)
}

// Client stub implementations.

type ping1_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping1_client_stub implements the Ping1 interface.
var _ Ping1 = &ping1_client_stub{}

func (s ping1_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping1.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping1_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping1.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping10_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping10_client_stub implements the Ping10 interface.
var _ Ping10 = &ping10_client_stub{}

func (s ping10_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping10.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping10_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping10.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping2_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping2_client_stub implements the Ping2 interface.
var _ Ping2 = &ping2_client_stub{}

func (s ping2_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping2.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping2_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping2.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping3_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping3_client_stub implements the Ping3 interface.
var _ Ping3 = &ping3_client_stub{}

func (s ping3_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping3.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping3_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping3.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping4_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping4_client_stub implements the Ping4 interface.
var _ Ping4 = &ping4_client_stub{}

func (s ping4_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping4.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping4_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping4.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping5_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping5_client_stub implements the Ping5 interface.
var _ Ping5 = &ping5_client_stub{}

func (s ping5_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping5.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping5_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping5.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping6_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping6_client_stub implements the Ping6 interface.
var _ Ping6 = &ping6_client_stub{}

func (s ping6_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping6.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping6_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping6.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping7_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping7_client_stub implements the Ping7 interface.
var _ Ping7 = &ping7_client_stub{}

func (s ping7_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping7.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping7_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping7.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping8_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping8_client_stub implements the Ping8 interface.
var _ Ping8 = &ping8_client_stub{}

func (s ping8_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping8.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping8_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping8.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type ping9_client_stub struct {
	stub         codegen.Stub
	pingCMetrics *codegen.MethodMetrics
	pingSMetrics *codegen.MethodMetrics
}

// Check that ping9_client_stub implements the Ping9 interface.
var _ Ping9 = &ping9_client_stub{}

func (s ping9_client_stub) PingC(ctx context.Context, a0 payloadC, a1 int) (r0 payloadC, err error) {
	// Update metrics.
	start := time.Now()
	s.pingCMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping9.PingC", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingCMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingCMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += serviceweaver_size_payloadC_7e82696e(&a0)
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingCMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingCMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s ping9_client_stub) PingS(ctx context.Context, a0 payloadS, a1 int) (r0 payloadS, err error) {
	// Update metrics.
	start := time.Now()
	s.pingSMetrics.Count.Add(1)

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "benchmarks.Ping9.PingS", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
			s.pingSMetrics.ErrorCount.Add(1)
		}
		span.End()

		s.pingSMetrics.Latency.Put(float64(time.Since(start).Microseconds()))
	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	enc.Int(a1)
	var shardKey uint64

	// Call the remote method.
	s.pingSMetrics.BytesRequest.Put(float64(len(enc.Data())))
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}
	s.pingSMetrics.BytesReply.Put(float64(len(results)))

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

// Server stub implementations.

type ping1_server_stub struct {
	impl    Ping1
	addLoad func(key uint64, load float64)
}

// Check that ping1_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping1_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping1_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping1_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping1_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping10_server_stub struct {
	impl    Ping10
	addLoad func(key uint64, load float64)
}

// Check that ping10_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping10_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping10_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping10_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping10_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping2_server_stub struct {
	impl    Ping2
	addLoad func(key uint64, load float64)
}

// Check that ping2_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping2_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping2_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping2_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping2_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping3_server_stub struct {
	impl    Ping3
	addLoad func(key uint64, load float64)
}

// Check that ping3_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping3_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping3_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping3_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping3_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping4_server_stub struct {
	impl    Ping4
	addLoad func(key uint64, load float64)
}

// Check that ping4_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping4_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping4_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping4_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping4_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping5_server_stub struct {
	impl    Ping5
	addLoad func(key uint64, load float64)
}

// Check that ping5_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping5_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping5_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping5_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping5_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping6_server_stub struct {
	impl    Ping6
	addLoad func(key uint64, load float64)
}

// Check that ping6_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping6_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping6_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping6_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping6_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping7_server_stub struct {
	impl    Ping7
	addLoad func(key uint64, load float64)
}

// Check that ping7_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping7_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping7_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping7_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping7_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping8_server_stub struct {
	impl    Ping8
	addLoad func(key uint64, load float64)
}

// Check that ping8_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping8_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping8_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping8_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping8_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type ping9_server_stub struct {
	impl    Ping9
	addLoad func(key uint64, load float64)
}

// Check that ping9_server_stub implements the codegen.Server interface.
var _ codegen.Server = &ping9_server_stub{}

// GetStubFn implements the codegen.Server interface.
func (s ping9_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "PingC":
		return s.pingC
	case "PingS":
		return s.pingS
	default:
		return nil
	}
}

func (s ping9_server_stub) pingC(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadC
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingC(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s ping9_server_stub) pingS(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 payloadS
	(&a0).WeaverUnmarshal(dec)
	var a1 int
	a1 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.PingS(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

// AutoMarshal implementations.

var _ codegen.AutoMarshal = &X1{}

type __is_X1[T ~struct {
	weaver.AutoMarshal
	A X2
	B []int64
}] struct{}

var _ __is_X1[X1]

func (x *X1) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("X1.WeaverMarshal: nil receiver"))
	}
	(x.A).WeaverMarshal(enc)
	serviceweaver_enc_slice_int64_a8f7f092(enc, x.B)
}

func (x *X1) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("X1.WeaverUnmarshal: nil receiver"))
	}
	(&x.A).WeaverUnmarshal(dec)
	x.B = serviceweaver_dec_slice_int64_a8f7f092(dec)
}

func serviceweaver_enc_slice_int64_a8f7f092(enc *codegen.Encoder, arg []int64) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		enc.Int64(arg[i])
	}
}

func serviceweaver_dec_slice_int64_a8f7f092(dec *codegen.Decoder) []int64 {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]int64, n)
	for i := 0; i < n; i++ {
		res[i] = dec.Int64()
	}
	return res
}

var _ codegen.AutoMarshal = &X2{}

type __is_X2[T ~struct {
	weaver.AutoMarshal
	A X3
}] struct{}

var _ __is_X2[X2]

func (x *X2) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("X2.WeaverMarshal: nil receiver"))
	}
	(x.A).WeaverMarshal(enc)
}

func (x *X2) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("X2.WeaverUnmarshal: nil receiver"))
	}
	(&x.A).WeaverUnmarshal(dec)
}

var _ codegen.AutoMarshal = &X3{}

type __is_X3[T ~struct {
	weaver.AutoMarshal
	A X4
	B int64
	C int64
}] struct{}

var _ __is_X3[X3]

func (x *X3) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("X3.WeaverMarshal: nil receiver"))
	}
	(x.A).WeaverMarshal(enc)
	enc.Int64(x.B)
	enc.Int64(x.C)
}

func (x *X3) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("X3.WeaverUnmarshal: nil receiver"))
	}
	(&x.A).WeaverUnmarshal(dec)
	x.B = dec.Int64()
	x.C = dec.Int64()
}

var _ codegen.AutoMarshal = &X4{}

type __is_X4[T ~struct {
	weaver.AutoMarshal
	A int64
	B X5
	C int64
}] struct{}

var _ __is_X4[X4]

func (x *X4) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("X4.WeaverMarshal: nil receiver"))
	}
	enc.Int64(x.A)
	(x.B).WeaverMarshal(enc)
	enc.Int64(x.C)
}

func (x *X4) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("X4.WeaverUnmarshal: nil receiver"))
	}
	x.A = dec.Int64()
	(&x.B).WeaverUnmarshal(dec)
	x.C = dec.Int64()
}

var _ codegen.AutoMarshal = &X5{}

type __is_X5[T ~struct {
	weaver.AutoMarshal
	A int64
	B int64
}] struct{}

var _ __is_X5[X5]

func (x *X5) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("X5.WeaverMarshal: nil receiver"))
	}
	enc.Int64(x.A)
	enc.Int64(x.B)
}

func (x *X5) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("X5.WeaverUnmarshal: nil receiver"))
	}
	x.A = dec.Int64()
	x.B = dec.Int64()
}

var _ codegen.AutoMarshal = &X6{}

type __is_X6[T ~struct {
	weaver.AutoMarshal
	A []bool
}] struct{}

var _ __is_X6[X6]

func (x *X6) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("X6.WeaverMarshal: nil receiver"))
	}
	serviceweaver_enc_slice_bool_c791c3b0(enc, x.A)
}

func (x *X6) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("X6.WeaverUnmarshal: nil receiver"))
	}
	x.A = serviceweaver_dec_slice_bool_c791c3b0(dec)
}

func serviceweaver_enc_slice_bool_c791c3b0(enc *codegen.Encoder, arg []bool) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		enc.Bool(arg[i])
	}
}

func serviceweaver_dec_slice_bool_c791c3b0(dec *codegen.Decoder) []bool {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]bool, n)
	for i := 0; i < n; i++ {
		res[i] = dec.Bool()
	}
	return res
}

var _ codegen.AutoMarshal = &payloadC{}

type __is_payloadC[T ~struct {
	weaver.AutoMarshal
	A float64
	B string
	C int64
	D X1
	E string
	F int64
	G X6
	H string
	I int64
	J float32
	K string
}] struct{}

var _ __is_payloadC[payloadC]

func (x *payloadC) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("payloadC.WeaverMarshal: nil receiver"))
	}
	enc.Float64(x.A)
	enc.String(x.B)
	enc.Int64(x.C)
	(x.D).WeaverMarshal(enc)
	enc.String(x.E)
	enc.Int64(x.F)
	(x.G).WeaverMarshal(enc)
	enc.String(x.H)
	enc.Int64(x.I)
	enc.Float32(x.J)
	enc.String(x.K)
}

func (x *payloadC) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("payloadC.WeaverUnmarshal: nil receiver"))
	}
	x.A = dec.Float64()
	x.B = dec.String()
	x.C = dec.Int64()
	(&x.D).WeaverUnmarshal(dec)
	x.E = dec.String()
	x.F = dec.Int64()
	(&x.G).WeaverUnmarshal(dec)
	x.H = dec.String()
	x.I = dec.Int64()
	x.J = dec.Float32()
	x.K = dec.String()
}

var _ codegen.AutoMarshal = &payloadS{}

type __is_payloadS[T ~struct {
	weaver.AutoMarshal
	Values []string
}] struct{}

var _ __is_payloadS[payloadS]

func (x *payloadS) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("payloadS.WeaverMarshal: nil receiver"))
	}
	serviceweaver_enc_slice_string_4af10117(enc, x.Values)
}

func (x *payloadS) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("payloadS.WeaverUnmarshal: nil receiver"))
	}
	x.Values = serviceweaver_dec_slice_string_4af10117(dec)
}

func serviceweaver_enc_slice_string_4af10117(enc *codegen.Encoder, arg []string) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		enc.String(arg[i])
	}
}

func serviceweaver_dec_slice_string_4af10117(dec *codegen.Decoder) []string {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]string, n)
	for i := 0; i < n; i++ {
		res[i] = dec.String()
	}
	return res
}

// Size implementations.

// serviceweaver_size_X1_25e7d26b returns the size (in bytes) of the serialization
// of the provided type.
func serviceweaver_size_X1_25e7d26b(x *X1) int {
	size := 0
	size += 0
	size += serviceweaver_size_X2_4061aeb8(&x.A)
	size += (4 + (len(x.B) * 8))
	return size
}

// serviceweaver_size_X2_4061aeb8 returns the size (in bytes) of the serialization
// of the provided type.
func serviceweaver_size_X2_4061aeb8(x *X2) int {
	size := 0
	size += 0
	size += serviceweaver_size_X3_25c4a6ab(&x.A)
	return size
}

// serviceweaver_size_X3_25c4a6ab returns the size (in bytes) of the serialization
// of the provided type.
func serviceweaver_size_X3_25c4a6ab(x *X3) int {
	size := 0
	size += 0
	size += serviceweaver_size_X4_d3ce6092(&x.A)
	size += 8
	size += 8
	return size
}

// serviceweaver_size_X4_d3ce6092 returns the size (in bytes) of the serialization
// of the provided type.
func serviceweaver_size_X4_d3ce6092(x *X4) int {
	size := 0
	size += 0
	size += 8
	size += serviceweaver_size_X5_474b9a71(&x.B)
	size += 8
	return size
}

// serviceweaver_size_X5_474b9a71 returns the size (in bytes) of the serialization
// of the provided type.
func serviceweaver_size_X5_474b9a71(x *X5) int {
	size := 0
	size += 0
	size += 8
	size += 8
	return size
}

// serviceweaver_size_X6_7a3484cc returns the size (in bytes) of the serialization
// of the provided type.
func serviceweaver_size_X6_7a3484cc(x *X6) int {
	size := 0
	size += 0
	size += (4 + (len(x.A) * 1))
	return size
}

// serviceweaver_size_payloadC_7e82696e returns the size (in bytes) of the serialization
// of the provided type.
func serviceweaver_size_payloadC_7e82696e(x *payloadC) int {
	size := 0
	size += 0
	size += 8
	size += (4 + len(x.B))
	size += 8
	size += serviceweaver_size_X1_25e7d26b(&x.D)
	size += (4 + len(x.E))
	size += 8
	size += serviceweaver_size_X6_7a3484cc(&x.G)
	size += (4 + len(x.H))
	size += 8
	size += 4
	size += (4 + len(x.K))
	return size
}
