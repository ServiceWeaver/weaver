// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package sim...
//
// TODO(mwhittaker): Write comprehensive package documentation with examples.
// We also probably want to put some of this documentation on the website, and
// we might also want to write a blog.
//
// TODO(mwhittaker): Move things to the weavertest package.
package sim

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"path/filepath"
	"reflect"
	"runtime"
	"sort"
	"strings"
	"sync"
	"sync/atomic"
	"testing"
	"time"

	"github.com/ServiceWeaver/weaver/internal/reflection"
	"github.com/ServiceWeaver/weaver/internal/weaver"
	swruntime "github.com/ServiceWeaver/weaver/runtime"
	"github.com/ServiceWeaver/weaver/runtime/codegen"
	"github.com/ServiceWeaver/weaver/runtime/logging"
	"github.com/ServiceWeaver/weaver/runtime/protos"
	"golang.org/x/exp/maps"
)

// FakeComponent is a copy of weavertest.FakeComponent. It's needed to access
// the unexported fields.
//
// TODO(mwhittaker): Remove this once we merge with weavertest.
type FakeComponent struct {
	intf reflect.Type
	impl any
}

// Fake is a copy of weavertest.Fake.
//
// TODO(mwhittaker): Remove this once we merge with the weavertest package.
func Fake[T any](impl any) FakeComponent {
	t := reflection.Type[T]()
	if _, ok := impl.(T); !ok {
		panic(fmt.Sprintf("%T does not implement %v", impl, t))
	}
	return FakeComponent{intf: t, impl: impl}
}

// A Generator[T] generates random values of type T.
type Generator[T any] interface {
	// Generate returns a randomly generated value of type T. While Generate is
	// "random", it must be deterministic. That is, given the same instance of
	// *rand.Rand, Generate must always return the same value.
	//
	// TODO(mwhittaker): Generate should maybe take something other than a
	// *rand.Rand?
	Generate(*rand.Rand) T
}

// A Registrar is used to register fakes and generators with a [Simulator].
type Registrar interface {
	// RegisterFake registers a fake implementation of a component.
	RegisterFake(FakeComponent)

	// RegisterGenerators registers generators for a workload method, one
	// generator per method argument. The number and type of the registered
	// generators must match the method. For example, given the method:
	//
	//     Foo(context.Context, int, bool) error
	//
	// we must register a Generator[int] and a Generator[bool]:
	//
	//     var r Registrar = ...
	//     var i Generator[int] = ...
	//     var b Generator[bool] = ...
	//     r.RegisterGenerators("Foo", i, b)
	//
	// TODO(mwhittaker): Allow people to register a func(*rand.Rand) T instead
	// of a Generator[T] for convenience.
	RegisterGenerators(method string, generators ...any)
}

// A Workload defines the set of operations to run as part of a simulation.
// Every workload is defined as a named struct. To execute a workload, a
// simulator constructs an instance of the struct, calls the struct's Init
// method, and then randomly calls the struct's exported methods. For example,
// the following is a simple workload:
//
//	type myWorkload struct {}
//	func (w *myWorkload) Init(r sim.Registrar) {...}
//	func (w *myWorkload) Foo(context.Context, int) error {...}
//	func (w *myWorkload) Bar(context.Context, bool, string) error {...}
//	func (w *myWorkload) baz(context.Context) error {...}
//
// When this workload is executed, its Foo and Bar methods will be called with
// random values generated by the generators registered in the Init method (see
// [Registrar] for details). Note that unexported methods, like baz, are
// ignored.
//
// Note that every exported workload method must receive a [context.Context] as
// its first argument and must return a single error value. A simulation is
// aborted when a method returns a non-nil error.
//
// TODO(mwhittaker): For now, the Init method is required. In the future, we
// could make it optional and use default generators for methods.
type Workload interface {
	// Init initializes a workload. The Init method must also register
	// generators for every exported method.
	Init(Registrar) error
}

// Options configure a Simulator.
type Options struct {
	// TOML config file contents.
	Config string

	// The number of executions to run in parallel. If Parallelism is 0, the
	// simulator picks the degree of parallelism.
	Parallelism int
}

// A Simulator deterministically simulates a Service Weaver application. See
// the package documentation for instructions on how to use a Simulator.
type Simulator struct {
	opts       Options                                // options
	t          testing.TB                             // underlying test
	w          reflect.Type                           // workload type
	regsByIntf map[reflect.Type]*codegen.Registration // components, by interface
	info       componentInfo                          // component metadata
	config     *protos.AppConfig                      // application config
}

// Results are the results of simulating a workload.
type Results struct {
	Err           error         // first non-nil error returned by an op
	History       []Event       // a history of the error inducing run, if Err is not nil
	NumExecutions int           // number of executions ran
	NumOps        int           // number of ops ran
	Duration      time.Duration // duration of simulation
}

// New returns a new Simulator that simulates the provided workload.
func New(t testing.TB, x Workload, opts Options) *Simulator {
	t.Helper()

	// Parse config.
	app := &protos.AppConfig{}
	if opts.Config != "" {
		var err error
		app, err = swruntime.ParseConfig("", opts.Config, codegen.ComponentConfigValidator)
		if err != nil {
			t.Fatalf("sim.New: parse config: %v", err)
		}
	}

	// Methods can have either value or pointer receivers. For example,
	// consider the following code:
	//
	//     type t struct{}
	//     func (t) ValueReceiver() {}
	//     func (*t) PointerReceiver() {}
	//
	// According to the Go spec, the method set of t includes only
	// ValueReceiver, while the method set of *t includes ValueReceiver and
	// PointerReceiver [1]. We want to call *every* exported method on a
	// workload struct, so we need to massage the type of x into a pointer if
	// it isn't already.
	//
	// [1]: https://go.dev/ref/spec#Method_sets
	w := reflect.TypeOf(x)
	if w.Kind() != reflect.Ptr {
		w = reflect.PointerTo(w)
	}

	// Validate the workload struct.
	if err := validateWorkload(w); err != nil {
		t.Fatalf("sim.New: invalid workload type %v: %v", w, err)
	}

	// Gather the set of registered components.
	//
	// TODO(mwhittaker): Only use the components actually referenced by the
	// workload.
	registered := map[reflect.Type]struct{}{}
	regsByIntf := map[reflect.Type]*codegen.Registration{}
	info := componentInfo{
		hasRefs:      map[reflect.Type]bool{},
		hasListeners: map[reflect.Type]bool{},
		hasConfig:    map[reflect.Type]bool{},
	}
	for _, reg := range codegen.Registered() {
		x := reflect.New(reg.Impl).Interface()
		registered[reg.Iface] = struct{}{}
		regsByIntf[reg.Iface] = reg
		info.hasRefs[reg.Iface] = weaver.HasRefs(x)
		info.hasListeners[reg.Iface] = weaver.HasListeners(x)
		info.hasConfig[reg.Iface] = weaver.HasConfig(x)
	}

	// Call Init and validate the registered fakes and generators.
	r := newRegistrar(t, w, registered)
	if err := x.Init(r); err != nil {
		t.Fatalf("sim.New: %v", err)
	}
	if err := r.finalize(); err != nil {
		t.Fatalf("sim.New: %v", err)
	}

	return &Simulator{opts, t, w, regsByIntf, info, app}
}

// validateWorkload validates a workload struct of the provided type.
func validateWorkload(w reflect.Type) error {
	var errs []error
	numOps := 0
	for i := 0; i < w.NumMethod(); i++ {
		m := w.Method(i)
		if m.Name == "Init" {
			continue
		}
		numOps++

		// Method should have type func(context.Context, ...) error.
		err := fmt.Errorf("method %s has type '%v' but should have type 'func(%v, context.Context, ...) error'", m.Name, m.Type, w)
		switch {
		case m.Type.NumIn() < 2:
			errs = append(errs, fmt.Errorf("%w: no arguments", err))
		case m.Type.In(1) != reflection.Type[context.Context]():
			errs = append(errs, fmt.Errorf("%w: first argument is not context.Context", err))
		case m.Type.NumOut() == 0:
			errs = append(errs, fmt.Errorf("%w: no return value", err))
		case m.Type.NumOut() > 1:
			errs = append(errs, fmt.Errorf("%w: too many return values", err))
		case m.Type.Out(0) != reflection.Type[error]():
			errs = append(errs, fmt.Errorf("%w: return value is not error", err))
		}
	}
	if numOps == 0 {
		errs = append(errs, fmt.Errorf("no exported methods"))
	}
	return errors.Join(errs...)
}

// newExecutor returns a new executor.
func (s *Simulator) newExecutor() *executor {
	return newExecutor(s.t, s.w, s.regsByIntf, s.info, s.config)
}

// Run runs simulations for the provided duration.
func (s *Simulator) Run(duration time.Duration) Results {
	// TODO(mwhittaker): Use a smarter algorithm to sweep over hyperparameters.
	start := time.Now()
	ctx, cancel := context.WithTimeout(context.Background(), duration)
	defer cancel()

	// Read graveyard entries.
	// TODO(mwhittaker): Escape names.
	graveyard, err := readGraveyard(filepath.Join("testdata", "sim", s.t.Name()))
	if err != nil {
		s.t.Fatal(err)
	}

	// Spawn n concurrent executors. The executors read hyperparamters from the
	// params channel and write errors and failed results to the errs and
	// failedResults channels. Simulation ends when we encounter an error or
	// successfully find an invariant violation.
	//
	// TODO(mwhittaker): Optimize things and pick a smarter value of n.
	n := s.opts.Parallelism
	if n == 0 {
		n = 10 * runtime.NumCPU()
	}
	params := make(chan hyperparameters, n)
	errs := make(chan error, n)
	failedResults := make(chan result, n)
	numExecutions := int64(0)
	numOps := int64(0)

	// Spawn n executors.
	done := sync.WaitGroup{}
	done.Add(n)
	for i := 0; i < n; i++ {
		go func() {
			defer done.Done()
			exec := s.newExecutor()
			for {
				select {
				case <-ctx.Done():
					return
				case p := <-params:
					result, err := exec.execute(ctx, p)
					switch {
					case err != nil && err == ctx.Err():
						// The execution was cancelled because the deadline was
						// met. Stop executing.
						return
					case err != nil:
						// The execution failed to execute properly. Abort.
						errs <- err
						return
					case result.err != nil:
						// The execution successfully found an invariant
						// violation. Return the result and stop execution.
						atomic.AddInt64(&numExecutions, 1)
						atomic.AddInt64(&numOps, int64(p.NumOps))
						failedResults <- result
						return
					default:
						// The execution ran without finding an invariant
						// violation. Move on to the next execution.
						atomic.AddInt64(&numExecutions, 1)
						atomic.AddInt64(&numOps, int64(p.NumOps))
					}
				}
			}
		}()
	}

	// Spawn a goroutine that writes to the params channel.
	done.Add(1)
	go func() {
		defer done.Done()

		// Re-run graveyard entries first.
		for _, entry := range graveyard {
			p := hyperparameters{
				Seed:        entry.Seed,
				NumReplicas: entry.NumReplicas,
				NumOps:      entry.NumOps,
				FailureRate: entry.FailureRate,
				YieldRate:   entry.YieldRate,
			}
			select {
			case <-ctx.Done():
				return
			case params <- p:
			}
		}

		// Run new entries.
		seed := time.Now().UnixNano()
		for numOps := 1; ; numOps++ {
			for _, failureRate := range []float64{0.0, 0.01, 0.05, 0.1} {
				for _, yieldRate := range []float64{0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0} {
					for i := 0; i < 10; i++ {
						seed++
						p := hyperparameters{
							Seed:        seed,
							NumOps:      numOps,
							NumReplicas: 1,
							FailureRate: failureRate,
							YieldRate:   yieldRate,
						}
						select {
						case <-ctx.Done():
							return
						case params <- p:
						}
					}
				}
			}
		}
	}()

	select {
	case err := <-errs:
		// An execution failed to execute properly.
		s.t.Fatal(err)
		return Results{}
	case r := <-failedResults:
		// An execution successfully found an invariant violation.
		cancel()
		done.Wait()
		return Results{
			Err:           r.err,
			History:       r.history,
			NumExecutions: int(numExecutions),
			NumOps:        int(numOps),
			Duration:      time.Since(start),
		}
	case <-ctx.Done():
		// We hit our deadline. All simulations passed.
		done.Wait()
		return Results{
			NumExecutions: int(numExecutions),
			NumOps:        int(numOps),
			Duration:      time.Since(start),
		}
	}
}

// Summary returns a human readable summary of the results.
func (r *Results) Summary() string {
	duration := r.Duration.Truncate(time.Millisecond)
	simRate := float64(r.NumExecutions) / r.Duration.Seconds()
	opRate := float64(r.NumOps) / r.Duration.Seconds()
	prefix := "✅ No errors"
	if r.Err != nil {
		prefix = "❌ Error"
	}
	return fmt.Sprintf("%s found after %d ops across %d executions in %v (%0.2f execs/s, %0.2f ops/s).", prefix, r.NumOps, r.NumExecutions, duration, simRate, opRate)
}

// Mermaid returns a [mermaid] diagram that illustrates an execution history.
//
// [mermaid]: https://mermaid.js.org/
func (r *Results) Mermaid() string {
	// TODO(mwhittaker): Arrange replicas in topological order.

	// Some abbreviations to save typing.
	shorten := logging.ShortenComponent
	commas := func(xs []string) string { return strings.Join(xs, ", ") }

	// Gather the set of all ops and replicas.
	type replica struct {
		component string
		replica   int
	}
	var ops []EventOpStart
	replicas := map[replica]struct{}{}
	calls := map[int]EventCall{}
	returns := map[int]EventReturn{}
	for _, event := range r.History {
		switch x := event.(type) {
		case EventOpStart:
			ops = append(ops, x)
		case EventCall:
			calls[x.SpanID] = x
		case EventDeliverCall:
			call := calls[x.SpanID]
			replicas[replica{call.Component, x.Replica}] = struct{}{}
		case EventReturn:
			returns[x.SpanID] = x
		}
	}

	// Create the diagram.
	var b strings.Builder
	fmt.Fprintln(&b, "sequenceDiagram")

	// Create ops.
	for _, op := range ops {
		fmt.Fprintf(&b, "    participant op%d as Op %d\n", op.TraceID, op.TraceID)
	}

	// Create component replicas.
	sorted := maps.Keys(replicas)
	sort.Slice(sorted, func(i, j int) bool {
		if sorted[i].component != sorted[j].component {
			return sorted[i].component < sorted[j].component
		}
		return sorted[i].replica < sorted[j].replica
	})
	for _, replica := range sorted {
		fmt.Fprintf(&b, "    participant %s%d as %s %d\n", replica.component, replica.replica, shorten(replica.component), replica.replica)
	}

	// Create events.
	for _, event := range r.History {
		switch x := event.(type) {
		case EventOpStart:
			fmt.Fprintf(&b, "    note right of op%d: [%d:%d] %s(%s)\n", x.TraceID, x.TraceID, x.SpanID, x.Name, commas(x.Args))
		case EventOpFinish:
			fmt.Fprintf(&b, "    note right of op%d: [%d:%d] return %s\n", x.TraceID, x.TraceID, x.SpanID, x.Error)
		case EventDeliverCall:
			call := calls[x.SpanID]
			fmt.Fprintf(&b, "    %s%d->>%s%d: [%d:%d] %s.%s(%s)\n", call.Caller, call.Replica, call.Component, x.Replica, x.TraceID, x.SpanID, shorten(call.Component), call.Method, commas(call.Args))
		case EventDeliverReturn:
			call := calls[x.SpanID]
			ret := returns[x.SpanID]
			fmt.Fprintf(&b, "    %s%d->>%s%d: [%d:%d] return %s\n", ret.Component, ret.Replica, call.Caller, call.Replica, x.TraceID, x.SpanID, commas(ret.Returns))
		case EventDeliverError:
			call := calls[x.SpanID]
			fmt.Fprintf(&b, "    note right of %s%d: [%d:%d] RemoteCallError\n", call.Caller, call.Replica, x.TraceID, x.SpanID)
		}
	}
	return b.String()
}
