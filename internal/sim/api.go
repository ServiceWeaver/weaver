// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package sim...
//
// TODO(mwhittaker): Write comprehensive package documentation with examples.
// We also probably want to put some of this documentation on the website, and
// we might also want to write a blog.
//
// TODO(mwhittaker): Move things to the weavertest package.
package sim

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"path/filepath"
	"reflect"
	"sync"
	"sync/atomic"
	"testing"
	"time"

	"github.com/ServiceWeaver/weaver/internal/reflection"
	"github.com/ServiceWeaver/weaver/internal/weaver"
	swruntime "github.com/ServiceWeaver/weaver/runtime"
	"github.com/ServiceWeaver/weaver/runtime/codegen"
	"github.com/ServiceWeaver/weaver/runtime/protos"
)

// FakeComponent is a copy of weavertest.FakeComponent. It's needed to access
// the unexported fields.
//
// TODO(mwhittaker): Remove this once we merge with weavertest.
type FakeComponent struct {
	intf reflect.Type
	impl any
}

// Fake is a copy of weavertest.Fake.
//
// TODO(mwhittaker): Remove this once we merge with the weavertest package.
func Fake[T any](impl any) FakeComponent {
	t := reflection.Type[T]()
	if _, ok := impl.(T); !ok {
		panic(fmt.Sprintf("%T does not implement %v", impl, t))
	}
	return FakeComponent{intf: t, impl: impl}
}

// A Generator[T] generates random values of type T.
type Generator[T any] interface {
	// Generate returns a randomly generated value of type T. While Generate is
	// "random", it must be deterministic. That is, given the same instance of
	// *rand.Rand, Generate must always return the same value.
	//
	// TODO(mwhittaker): Generate should maybe take something other than a
	// *rand.Rand?
	Generate(*rand.Rand) T
}

// A Registrar is used to register fakes and generators with a simulator.
type Registrar interface {
	// RegisterFake registers a fake implementation of a component.
	RegisterFake(FakeComponent)

	// RegisterGenerators registers generators for a workload method, one
	// generator per method argument. The number and type of the registered
	// generators must match the method. For example, given the method:
	//
	//     Foo(context.Context, int, bool) error
	//
	// we must register a Generator[int] and a Generator[bool]:
	//
	//     var r Registrar = ...
	//     var i Generator[int] = ...
	//     var b Generator[bool] = ...
	//     r.RegisterGenerators("Foo", i, b)
	//
	// TODO(mwhittaker): Allow people to register a func(*rand.Rand) T instead
	// of a Generator[T] for convenience.
	RegisterGenerators(method string, generators ...any)
}

// A Workload defines the set of operations to run as part of a simulation.
// Every workload is defined as a named struct. To perform a simulation, a
// simulator constructs an instance of the struct, calls the struct's Init
// method, and then randomly calls the struct's exported methods. For example,
// the following is a simple workload:
//
//	type myWorkload struct {}
//	func (w *myWorkload) Init(r sim.Registrar) {...}
//	func (w *myWorkload) Foo(context.Context, int) error {...}
//	func (w *myWorkload) Bar(context.Context, bool, string) error {...}
//	func (w *myWorkload) baz(context.Context) error {...}
//
// When this workload is simulated, its Foo and Bar methods will be called with
// random values generated by the generators registered in the Init method (see
// [Registrar] for details). Note that unexported methods, like baz, are
// ignored.
//
// Note that every exported workload method must receive a context.Context as
// its first argument and must return a single error value. A simulation is
// aborted when a method returns a non-nil error.
//
// TODO(mwhittaker): For now, the Init method is required. In the future, we
// could make it optional and use default generators for methods.
type Workload interface {
	// Init initializes a workload. The Init method must also register
	// generators for every exported method.
	Init(Registrar) error
}

// Options configure a Simulator.
type Options struct {
	Config string // TOML config contents
}

// A Simulator deterministically simulates a Service Weaver application. See
// the package documentation for instructions on how to use a Simulator.
type Simulator struct {
	t          testing.TB                             // underlying test
	w          reflect.Type                           // workload type
	methods    map[string]reflect.Method              // exported non-Init methods, by name
	regsByIntf map[reflect.Type]*codegen.Registration // components, by interface
	info       componentInfo                          // component metadata
	config     *protos.AppConfig                      // application config
}

// An Event represents an atomic step of a simulation.
type Event interface {
	isEvent()
}

// EventOpStart represents the start of an op.
type EventOpStart struct {
	TraceID int      // trace id
	SpanID  int      // span id
	Name    string   // op name
	Args    []string // op arguments
}

// EventOpFinish represents the finish of an op.
type EventOpFinish struct {
	TraceID int    // trace id
	SpanID  int    // span id
	Error   string // returned error message
}

// EventCall represents a component method call.
type EventCall struct {
	TraceID   int      // trace id
	SpanID    int      // span id
	Caller    string   // calling component (or "op")
	Replica   int      // calling component replica (or op number)
	Component string   // component being called
	Method    string   // method being called
	Args      []string // method arguments
}

// EventDeliverCall represents a component method call being delivered.
type EventDeliverCall struct {
	TraceID   int    // trace id
	SpanID    int    // span id
	Component string // component being called
	Replica   int    // component replica being called
}

// EventReturn represents a component method call returning.
type EventReturn struct {
	TraceID   int      // trace id
	SpanID    int      // span id
	Component string   // component returning
	Replica   int      // component replica returning
	Returns   []string // return values
}

// EventDeliverReturn represents the delivery of a method return.
type EventDeliverReturn struct {
	TraceID int // trace id
	SpanID  int // span id
}

// EventDeliverError represents the injection of an error.
type EventDeliverError struct {
	TraceID int // trace id
	SpanID  int // span id
}

func (EventOpStart) isEvent()       {}
func (EventOpFinish) isEvent()      {}
func (EventCall) isEvent()          {}
func (EventDeliverCall) isEvent()   {}
func (EventReturn) isEvent()        {}
func (EventDeliverReturn) isEvent() {}
func (EventDeliverError) isEvent()  {}

var _ Event = EventOpStart{}
var _ Event = EventOpFinish{}
var _ Event = EventCall{}
var _ Event = EventDeliverCall{}
var _ Event = EventReturn{}
var _ Event = EventDeliverReturn{}
var _ Event = EventDeliverError{}

// Results are the results of simulating a workload.
type Results struct {
	Err            error         // first non-nil error returned by an op
	History        []Event       // a history of the error inducing run, if Err is not nil
	NumSimulations int           // number of simulations ran
	NumOps         int           // number of ops ran
	Duration       time.Duration // duration of simulations
}

// New returns a new Simulator that simulates the provided workload.
func New(t testing.TB, x Workload, opts Options) *Simulator {
	// Note that because the Init method on a workload struct T often has a
	// pointer receiver *T, it is the pointer *T (rather than T itself) that
	// implements the Workload interface.
	t.Helper()

	// Parse config.
	app := &protos.AppConfig{}
	if opts.Config != "" {
		var err error
		app, err = swruntime.ParseConfig("", opts.Config, codegen.ComponentConfigValidator)
		if err != nil {
			t.Fatalf("sim.New: parse config: %v", err)
		}
	}

	// Methods can have either value or pointer receivers. For example,
	// consider the following code:
	//
	//     type t struct{}
	//     func (t) ValueReceiver() {}
	//     func (*t) PointerReceiver() {}
	//
	// According to the Go spec, the method set of t includes only
	// ValueReceiver, while the method set of *t includes ValueReceiver and
	// PointerReceiver [1]. We want to call *every* exported method on a
	// workload struct, so we need to massage the type of x into a pointer if
	// it isn't already.
	//
	// [1]: https://go.dev/ref/spec#Method_sets
	w := reflect.TypeOf(x)
	if w.Kind() != reflect.Ptr {
		w = reflect.PointerTo(w)
	}

	// Validate the workload struct.
	if err := validateWorkload(w); err != nil {
		t.Fatalf("sim.New: invalid workload type %v: %v", w, err)
	}

	// Gather the set of registered components.
	//
	// TODO(mwhittaker): Only use the components actually referenced by the
	// workload.
	regs := codegen.Registered()
	regsByIntf := map[reflect.Type]*codegen.Registration{}
	info := componentInfo{
		hasRefs:      make(map[reflect.Type]bool, len(regs)),
		hasListeners: make(map[reflect.Type]bool, len(regs)),
		hasConfig:    make(map[reflect.Type]bool, len(regs)),
	}
	for _, reg := range regs {
		x := reflect.New(reg.Impl).Interface()
		regsByIntf[reg.Iface] = reg
		info.hasRefs[reg.Iface] = weaver.HasRefs(x)
		info.hasListeners[reg.Iface] = weaver.HasListeners(x)
		info.hasConfig[reg.Iface] = weaver.HasConfig(x)
	}

	// Gather the set of methods.
	methods := map[string]reflect.Method{}
	for i := 0; i < w.NumMethod(); i++ {
		m := w.Method(i)
		if m.Name == "Init" {
			continue
		}
		methods[m.Name] = m
	}

	// Call Init and validate the registered fakes and generators.
	s := &Simulator{t, w, methods, regsByIntf, info, app}
	r := s.newRegistrar()
	if err := x.Init(r); err != nil {
		t.Fatalf("sim.New: %v", err)
	}
	if err := r.finalize(); err != nil {
		t.Fatalf("sim.New: %v", err)
	}
	return s
}

// validateWorkload validates a workload struct of the provided type.
func validateWorkload(t reflect.Type) error {
	var errs []error
	numOps := 0
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		if m.Name == "Init" {
			continue
		}
		numOps++

		// Method should have type func(context.Context, ...) error.
		err := fmt.Errorf("method %s has type '%v' but should have type 'func(%v, context.Context, ...) error'", m.Name, m.Type, t)
		switch {
		case m.Type.NumIn() < 2:
			errs = append(errs, fmt.Errorf("%w: no arguments", err))
		case m.Type.In(1) != reflection.Type[context.Context]():
			errs = append(errs, fmt.Errorf("%w: first argument is not context.Context", err))
		case m.Type.NumOut() == 0:
			errs = append(errs, fmt.Errorf("%w: no return value", err))
		case m.Type.NumOut() > 1:
			errs = append(errs, fmt.Errorf("%w: too many return values", err))
		case m.Type.Out(0) != reflection.Type[error]():
			errs = append(errs, fmt.Errorf("%w: return value is not error", err))
		}
	}
	if numOps == 0 {
		errs = append(errs, fmt.Errorf("no exported methods"))
	}
	return errors.Join(errs...)
}

// Run runs simulations for the provided duration.
func (s *Simulator) Run(duration time.Duration) Results {
	// Read graveyard entries.
	// TODO(mwhittaker): Escape names.
	graveyard, err := readGraveyard(filepath.Join("testdata", "sim", s.t.Name()))
	if err != nil {
		s.t.Fatal(err)
	}

	// TODO(mwhittaker): Use a smarter algorithm to sweep over hyperparameters.
	// TODO(mwhittaker): Read and run graveyard entries.
	start := time.Now()
	deadline := start.Add(duration)
	ctx, cancel := context.WithDeadline(context.Background(), deadline)
	defer cancel()

	// Spawn n concurrent simulators. The simulators read options from the opts
	// channel and write errors and failed results to the errs and
	// failedResults channels. Simulation ends when we encounter an error or
	// successfully find an invariant violation.
	//
	// TODO(mwhittaker): Optimize things and pick a smarter value of n.
	n := 1000
	opts := make(chan options, n)
	errs := make(chan error, n)
	failedResults := make(chan Results, n)
	done := sync.WaitGroup{}
	numSimulations := int64(0)
	numOps := int64(0)

	// Spawn n simulating goroutines that read from the opts channel.
	done.Add(n)
	for i := 0; i < n; i++ {
		go func() {
			defer done.Done()
			r := s.newRegistrar()
			sim := s.newSimulator()
			for {
				select {
				case <-ctx.Done():
					return
				case o := <-opts:
					r, err := s.simulateOne(ctx, r, sim, o)
					atomic.AddInt64(&numSimulations, 1)
					atomic.AddInt64(&numOps, int64(o.NumOps))
					switch {
					case err != nil && err == ctx.Err():
						// The simulation was cancelled because the deadline
						// was met. Stop executing simulations.
						return
					case err != nil:
						// The simulation failed to execute properly. Abort.
						errs <- err
						return
					case r.Err != nil:
						// The simulation successfully found an invariant
						// violation. Return the result and stop execution.
						failedResults <- r
						return
					default:
						// The simulation ran without finding an invariant
						// violation. Move on to the next simulation.
					}
				}
			}
		}()
	}

	// Spawn a goroutine that writes to the opts channel.
	done.Add(1)
	go func() {
		defer done.Done()

		// Re-run graveyard entries first.
		for _, entry := range graveyard {
			o := options{
				Seed:        entry.Seed,
				NumReplicas: entry.NumReplicas,
				NumOps:      entry.NumOps,
				FailureRate: entry.FailureRate,
				YieldRate:   entry.YieldRate,
			}
			select {
			case <-ctx.Done():
				return
			case opts <- o:
			}
		}

		// Run new entries.
		seed := time.Now().UnixNano()
		for numOps := 1; ; numOps++ {
			for _, failureRate := range []float64{0.0, 0.01, 0.05, 0.1} {
				for _, yieldRate := range []float64{0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0} {
					for i := 0; i < 10; i++ {
						seed++
						o := options{
							Seed:        seed,
							NumOps:      numOps,
							NumReplicas: 1,
							FailureRate: failureRate,
							YieldRate:   yieldRate,
						}
						select {
						case <-ctx.Done():
							return
						case opts <- o:
						}
					}
				}
			}
		}
	}()

	select {
	case err := <-errs:
		// A simulation failed to execute properly.
		s.t.Fatal(err)
		return Results{}
	case r := <-failedResults:
		// A simulation successfully found an invariant violation.
		cancel()
		done.Wait()
		r.NumSimulations = int(numSimulations)
		r.NumOps = int(numOps)
		r.Duration = time.Since(start)
		return r
	case <-ctx.Done():
		// We hit our deadline. All simulations passed.
		done.Wait()
		return Results{
			NumSimulations: int(numSimulations),
			NumOps:         int(numOps),
			Duration:       time.Since(start),
		}
	}
}

// newRegistar returns a new registrar.
func (s *Simulator) newRegistrar() *registrar {
	return newRegistrar(s.t, s.w, s.methods, s.regsByIntf)
}

// newWorkload returns a new, fully validated workload instance.
func (s *Simulator) newWorkload(ctx context.Context, r *registrar) (Workload, error) {
	// Construct an instance of the workload struct.
	workload := reflect.New(s.w.Elem()).Interface().(Workload)

	// Call the struct's Init method.
	r.reset()
	if err := workload.Init(r); err != nil {
		return nil, err
	}
	if err := r.finalize(); err != nil {
		return nil, err
	}
	return workload, nil
}

// newSimulator returns a new simulator.
func (s *Simulator) newSimulator() *simulator {
	return newSimulator(s.t.Name(), s.regsByIntf, s.info, s.config)
}

// simulateOne runs a single simulation.
func (s *Simulator) simulateOne(ctx context.Context, r *registrar, sim *simulator, opts options) (Results, error) {
	workload, err := s.newWorkload(ctx, r)
	if err != nil {
		return Results{}, err
	}
	if err := sim.reset(workload, r.fakes, r.ops, opts); err != nil {
		return Results{}, err
	}
	return sim.Simulate(ctx)
}

// registrar validates and collects registered fakes and components.
type registrar struct {
	// Immutable fields.
	t          testing.TB                             // underlying test
	w          reflect.Type                           // workload type
	regsByIntf map[reflect.Type]*codegen.Registration // registered components, by interface
	opsByName  map[string]int                         // index into ops, by name

	// Mutable fields.
	fakes map[reflect.Type]any // fakes, by component interface
	ops   []*op                // operations
}

// newRegistrar returns a new registrar.
func newRegistrar(t testing.TB, w reflect.Type, methods map[string]reflect.Method, regsByIntf map[reflect.Type]*codegen.Registration) *registrar {
	ops := make([]*op, 0, len(methods))
	opsByName := make(map[string]int, len(methods))
	i := 0
	for _, m := range methods {
		ops = append(ops, &op{
			t:          m.Type,
			name:       m.Name,
			arity:      m.Type.NumIn() - 2,
			generators: []generator{},
			f:          m.Func,
		})
		opsByName[m.Name] = i
		i++
	}
	return &registrar{
		t:          t,
		w:          w,
		regsByIntf: regsByIntf,
		fakes:      map[reflect.Type]any{},
		ops:        ops,
		opsByName:  opsByName,
	}
}

// reset resets a registrar.
func (r *registrar) reset() {
	for k := range r.fakes {
		delete(r.fakes, k)
	}
	for _, op := range r.ops {
		op.generators = op.generators[:0]
	}
}

// RegisterFake implements the Registrar interface.
func (r *registrar) RegisterFake(fake FakeComponent) {
	r.t.Helper()
	if err := r.registerFakes(fake); err != nil {
		r.t.Fatalf("RegisterFakes: %v", err)
	}
}

// RegisterGenerators implements the Registrar interface.
func (r *registrar) RegisterGenerators(method string, generators ...any) {
	r.t.Helper()
	if err := r.registerGenerators(method, generators...); err != nil {
		r.t.Fatalf("RegisterGenerators: %v", err)
	}
}

// registerFakes implements RegisterFakes.
func (r *registrar) registerFakes(fake FakeComponent) error {
	if _, ok := r.fakes[fake.intf]; ok {
		return fmt.Errorf("fake for %v already registered", fake.intf)
	}
	if _, ok := r.regsByIntf[fake.intf]; !ok {
		return fmt.Errorf("component %v not found", fake.intf)
	}
	r.fakes[fake.intf] = fake.impl
	return nil
}

// registerGenerators implements RegisterGenerators.
func (r *registrar) registerGenerators(method string, generators ...any) error {
	i, ok := r.opsByName[method]
	if !ok {
		return fmt.Errorf("method %q not found", method)
	}
	op := r.ops[i]
	if len(op.generators) > 0 {
		return fmt.Errorf("method %q generators already registered", method)
	}
	if got, want := len(generators), op.arity; got != want {
		return fmt.Errorf("method %v: want %d generators, got %d", method, want, got)
	}

	var errs []error
	for i, generator := range generators {
		// TODO(mwhittaker): Handle the case where a generator's Generate
		// method receives by pointer, but the user passed by value.
		t := reflect.TypeOf(generator)
		err := func() error {
			return fmt.Errorf("method %s generator %d is not a generator", method, i)
		}
		if t == nil {
			errs = append(errs, fmt.Errorf("%w: missing Generate method", err()))
			continue
		}

		// TODO(mwhittaker): If the Generator interface looked like this:
		//
		//     type Generator[T any] interface {
		//         Generate(*rand.Rand) any
		//     }
		//
		// then we could write `g, ok := generator.(Generator)`, which is much
		// faster. Think about how to speed things up without making the
		// interface ugly.
		generate, ok := t.MethodByName("Generate")
		switch {
		case !ok:
			errs = append(errs, fmt.Errorf("%w: missing Generate method", err()))
			continue
		case generate.Type.NumIn() < 2:
			errs = append(errs, fmt.Errorf("%w: Generate method has no arguments", err()))
			continue
		case generate.Type.NumIn() > 2:
			errs = append(errs, fmt.Errorf("%w: Generate method has too many arguments", err()))
			continue
		case generate.Type.In(1) != reflection.Type[*rand.Rand]():
			errs = append(errs, fmt.Errorf("%w: Generate argument is not *rand.Rand", err()))
			continue
		case generate.Type.NumOut() == 0:
			errs = append(errs, fmt.Errorf("%w: Generate method has no return values", err()))
			continue
		case generate.Type.NumOut() > 1:
			errs = append(errs, fmt.Errorf("%w: Generate method has too many return values", err()))
			continue
		case generate.Type.Out(0) != op.t.In(i+2):
			errs = append(errs, fmt.Errorf("method %s invalid generator %d: got Generator[%v], want Generator[%v]", method, i, generate.Type.Out(0), op.t.In(i+2)))
			continue
		}

		generator := generator
		op.generators = append(op.generators, func(r *rand.Rand) reflect.Value {
			in := []reflect.Value{reflect.ValueOf(generator), reflect.ValueOf(r)}
			return generate.Func.Call(in)[0]
		})
	}
	return errors.Join(errs...)
}

// finalize finalizes registration.
func (r *registrar) finalize() error {
	var errs []error
	for _, op := range r.ops {
		if len(op.generators) != op.arity {
			errs = append(errs, fmt.Errorf("no generators registered for method %s", op.name))
		}
	}
	return errors.Join(errs...)
}

// Summary returns a human readable summary of the results.
func (r *Results) Summary() string {
	duration := r.Duration.Truncate(time.Millisecond)
	simRate := float64(r.NumSimulations) / r.Duration.Seconds()
	opRate := float64(r.NumOps) / r.Duration.Seconds()
	prefix := "✅ No errors"
	if r.Err != nil {
		prefix = "❌ Error"
	}
	return fmt.Sprintf("%s found after %d ops across %d simulations in %v (%0.2f sims/s, %0.2f ops/s).", prefix, r.NumOps, r.NumSimulations, duration, simRate, opRate)
}
