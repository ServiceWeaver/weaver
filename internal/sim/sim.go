package sim

import (
	"context"
	"fmt"
	"math/rand"
	"reflect"
	"sort"
	"strings"

	"golang.org/x/exp/maps"
)

// A Caller allows a "component" to call methods on another "component". It is
// similar to a weaver.Ref.
type Caller interface {
	Call(component, method string, ctx context.Context, args ...any) (any, error)
}

// A Component interacts with other components via a Caller set by SetCaller.
type Component interface {
	SetCaller(Caller)
}

// Options configures a Simulator.
type Options struct {
	Seed        int64 // random number generator seed
	NumOps      int   // number of ops to run
	NumReplicas int   // number of replicas of every component
}

// A Simulator executes a workload with random interleavings of messages.
type Simulator struct {
	opts       Options
	components map[string]reflect.Type // components by name
	ops        map[string]*op          // ops by name
	replicas   map[string][]Component  // component replicas by name

	// NOTE: The following should be guarded by a mutex, but I'm not to keep
	// things simple.
	rand    *rand.Rand
	calls   []*call
	replies []*reply
	opId    int
	spanId  int
	history []Event
	done    chan error
}

// An Op[T] is an operation that is part of a workload run by a Simulator. An
// op is run on random values of type T generated by the simulator. If an op
// returns an error, the simulation is aborted with that error.
type Op[T any] func(Caller, context.Context, T) error

// Result is the result of a simulation.
type Result struct {
	History []Event // the history of simulated events
	Err     error   // the first error, if any, returned by an op
}

// op is a type-erased Op. See RegisterOp.
type op struct {
	t   reflect.Type // T in Op[T]
	f   any          // op function of type Op[T]
	gen any          // op generator of type Gen[T]
}

// call is a pending component method call.
type call struct {
	component string
	method    string
	ctx       context.Context
	args      []any
	reply     chan *reply
}

// reply is a pending component method call.
type reply struct {
	res     any
	err     error
	replier Instance
	reply   chan *reply
}

// A caller is the Caller used for an op or component replica. Every op and
// replica gets its own caller.
type caller struct {
	*Simulator
	instance Instance // instace of the op or component
}

var _ Caller = (*caller)(nil)

type breadcrumbKey struct{}

// A breadcrumb is like a trace context. It's used to propagate tracing and
// event information throughout a call graph.
type breadcrumb struct {
	opId   int
	spanId int
	parent Instance
}

func withBreadcrumb(ctx context.Context, id breadcrumb) context.Context {
	return context.WithValue(ctx, breadcrumbKey{}, id)
}

func extractBreadcrumb(ctx context.Context) breadcrumb {
	return ctx.Value(breadcrumbKey{}).(breadcrumb)
}

// New returns a new Simulator.
func New(opts Options) *Simulator {
	return &Simulator{
		opts:       opts,
		components: map[string]reflect.Type{},
		ops:        map[string]*op{},
		replicas:   map[string][]Component{},
		done:       make(chan error, 1),
		rand:       rand.New(rand.NewSource(opts.Seed)),
	}
}

type ComponentPointer[C any] interface {
	*C
	Component
}

// RegisterComponent registers a "component" with the provided simulator.
func RegisterComponent[C any, P ComponentPointer[C]](s *Simulator) {
	t := reflect.TypeOf((*C)(nil)).Elem()
	s.components[t.Name()] = t
}

// RegsiterOp registers an op with the provided simulator.
func RegisterOp[T any](s *Simulator, name string, gen Gen[T], f Op[T]) {
	s.ops[name] = &op{
		t:   reflect.TypeOf((*T)(nil)).Elem(),
		f:   f,
		gen: gen,
	}
}

// Simulate runs a simulation.
func (s *Simulator) Simulate() Result {
	// Instantiate component replicas.
	for name, t := range s.components {
		for i := 0; i < s.opts.NumReplicas; i++ {
			c := reflect.New(t).Interface().(Component)
			c.SetCaller(&caller{s, Instance{name, i}})
			if x, ok := c.(interface{ Init() }); ok {
				x.Init()
			}
			s.replicas[name] = append(s.replicas[name], c)
		}
	}

	// Spawn first op.
	s.spawnOp(pickKey(s.rand, s.ops))

	// Wait for the simulation to finish.
	err := <-s.done
	return Result{s.history, err}
}

// step performs one step in the simulation. It either
//
//  1. starts an op,
//  2. delivers a pending call, or
//  3. delivers a pending reply.
//
// In a more advanced implementation, it could also choose to initialize a new
// component replica, return an error to a pending call, establish a network
// partition, or clear a network partition.
func (s *Simulator) step() {
	if s.opId < s.opts.NumOps && flip(s.rand) {
		// Execute an op.
		s.spawnOp(pickKey(s.rand, s.ops))
		return
	}

	deliverReply := func() {
		var reply *reply
		reply, s.replies = pop(s.rand, s.replies)
		reply.reply <- reply
	}

	deliverCall := func() {
		var call *call
		call, s.calls = pop(s.rand, s.calls)
		s.deliverCall(call)
	}

	switch {
	case len(s.replies) > 0 && len(s.calls) > 0:
		if flip(s.rand) {
			deliverReply()
		} else {
			deliverCall()
		}
	case len(s.replies) > 0 && len(s.calls) == 0:
		deliverReply()
	case len(s.replies) == 0 && len(s.calls) > 0:
		deliverCall()
	case len(s.replies) == 0 && len(s.calls) == 0:
		// The simulation is over.
		s.done <- nil
	}
}

// record records an event in a simulator's history.
func (s *Simulator) record(e Event) {
	s.history = append(s.history, e)

	// Uncomment the following for debugging.
	// fmt.Printf("%#v\n", e)
}

// spawnOp spawn an op.
func (s *Simulator) spawnOp(name string) {
	// Form breadcrumb.
	b := breadcrumb{opId: s.opId, spanId: s.spanId}
	s.opId++
	s.spanId++

	// Generate arguments.
	ctx := context.Background()
	op := s.ops[name]
	out := reflect.ValueOf(op.gen).Call([]reflect.Value{reflect.ValueOf(s.rand)})
	args := []any{
		&caller{s, Instance{"Op", b.opId}},
		withBreadcrumb(ctx, b),
		out[0].Interface(),
	}

	// Record history.
	s.record(OpStartEvent{
		OpId:   b.opId,
		SpanId: b.spanId,
		Name:   name,
		Args:   args,
	})

	// Call op.
	go func() {
		f := reflect.ValueOf(op.f)
		in := []reflect.Value{
			reflect.ValueOf(args[0]),
			reflect.ValueOf(args[1]),
			reflect.ValueOf(args[2]),
		}
		results := f.Call(in)
		event := OpFinishEvent{
			OpId:   b.opId,
			SpanId: b.spanId,
		}
		if err := results[0].Interface(); err != nil {
			event.Err = err.(error)
			s.record(event)
			s.done <- err.(error)
			return
		}
		s.record(event)
		s.step()
	}()
}

// Call calls a component's method.
func (c *caller) Call(component, method string, ctx context.Context, args ...any) (any, error) {
	// Form breadcrumb.
	b := extractBreadcrumb(ctx)
	b = breadcrumb{
		opId:   b.opId,
		spanId: c.spanId,
		parent: c.instance,
	}
	c.spanId++

	// Record history.
	c.record(SendRequestEvent{
		OpId:      b.opId,
		SpanId:    b.spanId,
		Requester: b.parent,
		Component: component,
		Method:    method,
		Args:      args,
	})

	// Register call.
	reply := make(chan *reply, 1)
	c.calls = append(c.calls, &call{
		component: component,
		method:    method,
		ctx:       withBreadcrumb(ctx, b),
		args:      args,
		reply:     reply,
	})
	c.step()

	// Wait for response.
	r := <-reply
	c.record(ReceiveReplyEvent{
		OpId:      b.opId,
		SpanId:    b.spanId,
		Requester: b.parent,
		Replier:   r.replier,
		Reply:     r.res,
		Err:       r.err,
	})
	return r.res, r.err
}

// deliverCall delivers a pending method call to a component.
func (s *Simulator) deliverCall(call *call) {
	// Find the component method.
	replicas, ok := s.replicas[call.component]
	if !ok {
		panic(fmt.Errorf("component %q not found", call.component))
	}
	replicaId := s.rand.Intn(len(replicas))
	m := reflect.ValueOf(replicas[replicaId]).MethodByName(call.method)
	if m == (reflect.Value{}) {
		panic(fmt.Errorf("component %q method %q not found", call.component, call.method))
	}

	// Form the breadcrumb.
	b := extractBreadcrumb(call.ctx)

	// Record history.
	s.record(ReceiveRequestEvent{
		OpId:      b.opId,
		SpanId:    b.spanId,
		Requester: b.parent,
		Replier:   Instance{call.component, replicaId},
		Component: call.component,
		Method:    call.method,
		Args:      call.args,
	})

	go func() {
		// Call the component method.
		in := []reflect.Value{reflect.ValueOf(call.ctx)}
		for _, arg := range call.args {
			in = append(in, reflect.ValueOf(arg))
		}
		out := m.Call(in)

		// Extract the resulting types.
		res := out[0].Interface()
		err := out[1].Interface()
		reply := &reply{
			res:     res,
			replier: Instance{call.component, replicaId},
			reply:   call.reply,
		}
		if err != nil {
			reply.err = err.(error)
		}
		s.replies = append(s.replies, reply)

		// Record history.
		s.record(SendReplyEvent{
			OpId:      b.opId,
			SpanId:    b.spanId,
			Requester: b.parent,
			Replier:   Instance{call.component, replicaId},
			Reply:     reply.res,
			Err:       reply.err,
		})

		s.step()
	}()
}

// Mermaid returns a mermaid graph of the simulator's execution.
func (s *Simulator) Mermaid() string {
	op := func(i int) string { return fmt.Sprintf("Op %d", i) }
	comp := func(c string, i int) string { return fmt.Sprintf("%s %d", c, i) }

	var b strings.Builder
	fmt.Fprintln(&b, "sequenceDiagram")

	// Ops and Components.
	components := maps.Keys(s.components)
	sort.Strings(components)
	for _, component := range components {
		for i := 0; i < s.opts.NumReplicas; i++ {
			fmt.Fprintf(&b, "    participant %q\n", comp(component, i))
		}
	}

	// Events.
	for _, event := range s.history {
		switch x := event.(type) {
		case OpStartEvent:
			msg := fmt.Sprintf("Op %d: %s(%v)", x.OpId, x.Name, x.Args[2:])
			fmt.Fprintf(&b, "    participant %q as %q\n", op(x.OpId), msg)
		case OpFinishEvent:
			msg := fmt.Sprintf("%v", x.Err)
			fmt.Fprintf(&b, "    %q-->%q: %q\n", op(x.OpId), op(x.OpId), msg)
		case SendRequestEvent:
			msg := fmt.Sprintf("[%d:%d] %s.%s(%v)", x.OpId, x.SpanId, x.Component, x.Method, x.Args)
			fmt.Fprintf(&b, "    %q-->%q: %q\n", x.Requester, x.Requester, msg)
		case ReceiveRequestEvent:
			msg := fmt.Sprintf("[%d:%d] %s.%s(%v)", x.OpId, x.SpanId, x.Component, x.Method, x.Args)
			fmt.Fprintf(&b, "    %q->>%q: %q\n", x.Requester, x.Replier, msg)
		case SendReplyEvent:
			msg := fmt.Sprintf("[%d:%d] %v, %v", x.OpId, x.SpanId, x.Reply, x.Err)
			fmt.Fprintf(&b, "    %q-->%q: %q\n", x.Replier, x.Replier, msg)
		case ReceiveReplyEvent:
			msg := fmt.Sprintf("[%d:%d] %v, %v", x.OpId, x.SpanId, x.Reply, x.Err)
			fmt.Fprintf(&b, "    %q->>%q: %q\n", x.Replier, x.Requester, msg)
		default:
			panic(fmt.Errorf("unrecognized event type %T", event))
		}
	}

	return b.String()
}
