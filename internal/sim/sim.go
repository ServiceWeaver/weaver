// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// TODO(mwhittaker): Figure out which parts of the simulator need to be in an
// internal package and which parts can be in weavertest. Everything is
// internal for now.
package sim

import (
	"context"
	"fmt"
	"log/slog"
	"math/rand"
	"net"
	"reflect"
	"sync"

	"github.com/ServiceWeaver/weaver/internal/config"
	"github.com/ServiceWeaver/weaver/internal/reflection"
	"github.com/ServiceWeaver/weaver/internal/weaver"
	"github.com/ServiceWeaver/weaver/runtime"
	"github.com/ServiceWeaver/weaver/runtime/codegen"
	"github.com/ServiceWeaver/weaver/runtime/protos"
)

// An Op[T] is a randomized operation performed as part of a simulation.
type Op[T any] struct {
	// The name of the operation.
	Name string

	// A function that generates a "random" instance of type T. Gen should be
	// deterministic. That is, it should return the same value given the same
	// *rand.Rand.
	Gen func(*rand.Rand) T

	// The body of the operation. Func should be a function of the following
	// form:
	//
	//     func(context.Context, T, [Component]...) error
	//
	// Func's first argument is context.Context. It's second argument is T. The
	// remaining arguments must be registered component interface types. Func
	// is called on instances of T generated by Gen.
	//
	// A simulation executes a number of ops. The simulation fails if any op
	// returns a non-nil error.
	Func any
}

// Options configures a simulator.
type Options struct {
	Seed           int64  // the simulator's seed
	NumReplicas    int    // the number of replicas of every component
	ConfigFilename string // TOML config filename
	Config         string // TOML config contents
}

// Simulator deterministically simulates a Service Weaver application.
type Simulator struct {
	opts       Options
	config     *protos.AppConfig
	regs       []*codegen.Registration
	regsByIntf map[reflect.Type]*codegen.Registration
	components map[string][]any
	ops        map[string]op

	mu   sync.Mutex
	rand *rand.Rand
}

// op is a non-generic Op[T].
type op struct {
	t    reflect.Type // the T in Op[T]
	name string       // Op.Name
	gen  any          // Op.Gen
	f    any          // Op.Func
}

// New returns a new Simulator.
func New(opts Options) (*Simulator, error) {
	// Index registrations.
	regs := codegen.Registered()
	regsByIntf := map[reflect.Type]*codegen.Registration{}
	for _, reg := range regs {
		regsByIntf[reg.Iface] = reg
	}

	// Parse config.
	app := &protos.AppConfig{}
	if opts.Config != "" {
		var err error
		app, err = runtime.ParseConfig(opts.ConfigFilename, opts.Config, codegen.ComponentConfigValidator)
		if err != nil {
			return nil, fmt.Errorf("parse config: %w", err)
		}
	}

	// Create simulator.
	s := &Simulator{
		opts:       opts,
		config:     app,
		regs:       regs,
		regsByIntf: regsByIntf,
		components: map[string][]any{},
		ops:        map[string]op{},
		rand:       rand.New(rand.NewSource(opts.Seed)),
	}

	// Create component replicas.
	for _, reg := range regs {
		for i := 0; i < opts.NumReplicas; i++ {
			// Create the component implementation.
			v := reflect.New(reg.Impl)
			obj := v.Interface()

			// Fill config.
			if cfg := config.Config(v); cfg != nil {
				if err := runtime.ParseConfigSection(reg.Name, "", app.Sections, cfg); err != nil {
					return nil, err
				}
			}

			// Set logger.
			//
			// TODO(mwhittaker): Use custom logger.
			if err := weaver.SetLogger(obj, slog.Default()); err != nil {
				return nil, err
			}

			// Fill ref fields.
			if err := weaver.FillRefs(obj, func(t reflect.Type) (any, error) {
				return s.GetIntf(t)
			}); err != nil {
				return nil, err
			}

			// Fill listener fields.
			if err := weaver.FillListeners(obj, func(name string) (net.Listener, string, error) {
				lis, err := net.Listen("tcp", ":0")
				return lis, "", err
			}); err != nil {
				return nil, err
			}

			// Call Init if available.
			if i, ok := obj.(interface{ Init(context.Context) error }); ok {
				// TODO(mwhittaker): Use better context.
				if err := i.Init(context.Background()); err != nil {
					return nil, fmt.Errorf("component %q initialization failed: %w", reg.Name, err)
				}
			}

			s.components[reg.Name] = append(s.components[reg.Name], obj)
		}
	}

	return s, nil
}

// RegisterOp registers an operation with the provided simulator. RegisterOp
// panics if the provided op is invalid.
func RegisterOp[T any](s *Simulator, o Op[T]) {
	op, err := validateOp(s, o)
	if err != nil {
		panic(err)
	}
	s.ops[op.name] = op
}

// validateOp validates the provided Op[T] and converts it to an op.
func validateOp[T any](s *Simulator, o Op[T]) (op, error) {
	if _, ok := s.ops[o.Name]; ok {
		return op{}, fmt.Errorf("duplicate registration of op %q", o.Name)
	}

	// TODO(mwhittaker): Improve error messages.
	if o.Name == "" {
		return op{}, fmt.Errorf("missing op Name")
	}
	if o.Gen == nil {
		return op{}, fmt.Errorf("op %q has nil Gen", o.Name)
	}
	if o.Func == nil {
		return op{}, fmt.Errorf("op %q has nil Func", o.Name)
	}
	t := reflect.TypeOf(o.Func)
	if t.Kind() != reflect.Func {
		return op{}, fmt.Errorf("op %q func is not a function: %T", o.Name, o.Func)
	}
	if t.NumIn() < 2 {
		return op{}, fmt.Errorf("op %q func has < 2 arguments: %T", o.Name, o.Func)
	}
	if t.In(0) != reflection.Type[context.Context]() {
		return op{}, fmt.Errorf("op %q func's first argument is not context.Context: %T", o.Name, o.Func)
	}
	if t.In(1) != reflection.Type[T]() {
		return op{}, fmt.Errorf("op %q func's second argument is not %v: %T", o.Name, reflection.Type[T](), o.Func)
	}
	for i := 2; i < t.NumIn(); i++ {
		if _, ok := s.regsByIntf[t.In(i)]; !ok {
			return op{}, fmt.Errorf("op %q func argument %d is not a registered component: %T", o.Name, i, o.Func)
		}
	}
	if t.NumOut() != 1 {
		return op{}, fmt.Errorf("op %q func does not have exactly one return: %T", o.Name, o.Func)
	}
	if t.Out(0) != reflection.Type[error]() {
		return op{}, fmt.Errorf("op %q func does not return an error: %T", o.Name, o.Func)
	}

	return op{
		t:    reflection.Type[T](),
		name: o.Name,
		gen:  o.Gen,
		f:    o.Func,
	}, nil
}

// GetIntf implements the Weavelet interface.
func (s *Simulator) GetIntf(t reflect.Type) (any, error) {
	reg, ok := s.regsByIntf[t]
	if !ok {
		return nil, fmt.Errorf("component %v not found", t)
	}
	call := func(method string, ctx context.Context, args []any, returns []any) error {
		return s.call(reg, method, ctx, args, returns)
	}
	return reg.ReflectStubFn(call), nil
}

// call executes a component method call against a random replica.
func (s *Simulator) call(reg *codegen.Registration, method string, ctx context.Context, args []any, returns []any) error {
	// Pick a replica to execute the call.
	replicas := s.components[reg.Name]
	s.mu.Lock()
	i := s.rand.Intn(len(replicas))
	s.mu.Unlock()

	// Convert the arguments to reflect.Values.
	in := make([]reflect.Value, 1+len(args))
	in[0] = reflect.ValueOf(ctx)
	for i, arg := range args {
		in[i+1] = reflect.ValueOf(arg)
	}

	// Call the method.
	out := reflect.ValueOf(replicas[i]).MethodByName(method).Call(in)

	// Populate return values.
	if len(returns) != len(out)-1 {
		panic(fmt.Errorf("invalid number of returns: want %d, got %d", len(out)-1, len(returns)))
	}
	for i := 0; i < len(returns); i++ {
		// Note that returns[i] has static type any but dynamic type *T for
		// some T. out[i] has dynamic type T.
		reflect.ValueOf(returns[i]).Elem().Set(out[i])
	}
	if x := out[len(out)-1].Interface(); x != nil {
		return x.(error)
	}
	return nil
}
