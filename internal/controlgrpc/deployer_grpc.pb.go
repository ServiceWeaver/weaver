// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: internal/controlgrpc/deployer.proto

package controlgrpc

import (
	context "context"
	protos "github.com/ServiceWeaver/weaver/runtime/protos"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	DeployerControlGrpc_ActivateComponent_FullMethodName       = "/control.DeployerControlGrpc/ActivateComponent"
	DeployerControlGrpc_GetListenerAddress_FullMethodName      = "/control.DeployerControlGrpc/GetListenerAddress"
	DeployerControlGrpc_ExportListener_FullMethodName          = "/control.DeployerControlGrpc/ExportListener"
	DeployerControlGrpc_GetSelfCertificate_FullMethodName      = "/control.DeployerControlGrpc/GetSelfCertificate"
	DeployerControlGrpc_VerifyClientCertificate_FullMethodName = "/control.DeployerControlGrpc/VerifyClientCertificate"
	DeployerControlGrpc_VerifyServerCertificate_FullMethodName = "/control.DeployerControlGrpc/VerifyServerCertificate"
	DeployerControlGrpc_LogBatch_FullMethodName                = "/control.DeployerControlGrpc/LogBatch"
	DeployerControlGrpc_HandleTraceSpans_FullMethodName        = "/control.DeployerControlGrpc/HandleTraceSpans"
)

// DeployerControlGrpcClient is the client API for DeployerControlGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeployerControlGrpcClient interface {
	// ActivateComponent ensures that the provided component is running
	// somewhere. A call to ActivateComponent also implicitly signals that a
	// weavelet is interested in receiving routing info for the component.
	ActivateComponent(ctx context.Context, in *protos.ActivateComponentRequest, opts ...grpc.CallOption) (*protos.ActivateComponentReply, error)
	// GetListenerAddress returns the address the weavelet should listen on for
	// a particular listener.
	GetListenerAddress(ctx context.Context, in *protos.GetListenerAddressRequest, opts ...grpc.CallOption) (*protos.GetListenerAddressReply, error)
	// ExportListener exports the provided listener. Exporting a listener
	// typically, but not always, involves running a proxy that forwards
	// traffic to the provided address.
	ExportListener(ctx context.Context, in *protos.ExportListenerRequest, opts ...grpc.CallOption) (*protos.ExportListenerReply, error)
	// GetSelfCertificate returns the certificate and the private key the
	// weavelet should use for network connection establishment. The weavelet
	// will issue this request each time it establishes a connection with
	// another weavelet.
	// NOTE: This method is only called if mTLS was enabled for the weavelet,
	// by passing it a WeaveletArgs with mtls=true.
	GetSelfCertificate(ctx context.Context, in *protos.GetSelfCertificateRequest, opts ...grpc.CallOption) (*protos.GetSelfCertificateReply, error)
	// VerifyClientCertificate verifies the certificate chain presented by
	// a network client attempting to connect to the weavelet. It returns an
	// error if the network connection should not be established with the
	// client. Otherwise, it returns the list of weavelet components that the
	// client is authorized to invoke methods on.
	//
	// NOTE: This method is only called if mTLS was enabled for the weavelet,
	// by passing it a WeaveletArgs with mtls=true.
	VerifyClientCertificate(ctx context.Context, in *protos.VerifyClientCertificateRequest, opts ...grpc.CallOption) (*protos.VerifyClientCertificateReply, error)
	// VerifyServerCertificate verifies the certificate chain presented by
	// the server the weavelet is attempting to connect to. It returns an
	// error iff the server identity doesn't match the identity of the specified
	// component.
	//
	// NOTE: This method is only called if mTLS was enabled for the weavelet,
	// by passing it a WeaveletArgs with mtls=true.
	VerifyServerCertificate(ctx context.Context, in *protos.VerifyServerCertificateRequest, opts ...grpc.CallOption) (*protos.VerifyServerCertificateReply, error)
	// LogBatches handles a batch of log entries.
	LogBatch(ctx context.Context, in *protos.LogEntryBatch, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// HandleTraceSpans handles a set of trace spans.
	HandleTraceSpans(ctx context.Context, in *protos.TraceSpans, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type deployerControlGrpcClient struct {
	cc grpc.ClientConnInterface
}

func NewDeployerControlGrpcClient(cc grpc.ClientConnInterface) DeployerControlGrpcClient {
	return &deployerControlGrpcClient{cc}
}

func (c *deployerControlGrpcClient) ActivateComponent(ctx context.Context, in *protos.ActivateComponentRequest, opts ...grpc.CallOption) (*protos.ActivateComponentReply, error) {
	out := new(protos.ActivateComponentReply)
	err := c.cc.Invoke(ctx, DeployerControlGrpc_ActivateComponent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployerControlGrpcClient) GetListenerAddress(ctx context.Context, in *protos.GetListenerAddressRequest, opts ...grpc.CallOption) (*protos.GetListenerAddressReply, error) {
	out := new(protos.GetListenerAddressReply)
	err := c.cc.Invoke(ctx, DeployerControlGrpc_GetListenerAddress_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployerControlGrpcClient) ExportListener(ctx context.Context, in *protos.ExportListenerRequest, opts ...grpc.CallOption) (*protos.ExportListenerReply, error) {
	out := new(protos.ExportListenerReply)
	err := c.cc.Invoke(ctx, DeployerControlGrpc_ExportListener_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployerControlGrpcClient) GetSelfCertificate(ctx context.Context, in *protos.GetSelfCertificateRequest, opts ...grpc.CallOption) (*protos.GetSelfCertificateReply, error) {
	out := new(protos.GetSelfCertificateReply)
	err := c.cc.Invoke(ctx, DeployerControlGrpc_GetSelfCertificate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployerControlGrpcClient) VerifyClientCertificate(ctx context.Context, in *protos.VerifyClientCertificateRequest, opts ...grpc.CallOption) (*protos.VerifyClientCertificateReply, error) {
	out := new(protos.VerifyClientCertificateReply)
	err := c.cc.Invoke(ctx, DeployerControlGrpc_VerifyClientCertificate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployerControlGrpcClient) VerifyServerCertificate(ctx context.Context, in *protos.VerifyServerCertificateRequest, opts ...grpc.CallOption) (*protos.VerifyServerCertificateReply, error) {
	out := new(protos.VerifyServerCertificateReply)
	err := c.cc.Invoke(ctx, DeployerControlGrpc_VerifyServerCertificate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployerControlGrpcClient) LogBatch(ctx context.Context, in *protos.LogEntryBatch, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DeployerControlGrpc_LogBatch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployerControlGrpcClient) HandleTraceSpans(ctx context.Context, in *protos.TraceSpans, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DeployerControlGrpc_HandleTraceSpans_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeployerControlGrpcServer is the server API for DeployerControlGrpc service.
// All implementations must embed UnimplementedDeployerControlGrpcServer
// for forward compatibility
type DeployerControlGrpcServer interface {
	// ActivateComponent ensures that the provided component is running
	// somewhere. A call to ActivateComponent also implicitly signals that a
	// weavelet is interested in receiving routing info for the component.
	ActivateComponent(context.Context, *protos.ActivateComponentRequest) (*protos.ActivateComponentReply, error)
	// GetListenerAddress returns the address the weavelet should listen on for
	// a particular listener.
	GetListenerAddress(context.Context, *protos.GetListenerAddressRequest) (*protos.GetListenerAddressReply, error)
	// ExportListener exports the provided listener. Exporting a listener
	// typically, but not always, involves running a proxy that forwards
	// traffic to the provided address.
	ExportListener(context.Context, *protos.ExportListenerRequest) (*protos.ExportListenerReply, error)
	// GetSelfCertificate returns the certificate and the private key the
	// weavelet should use for network connection establishment. The weavelet
	// will issue this request each time it establishes a connection with
	// another weavelet.
	// NOTE: This method is only called if mTLS was enabled for the weavelet,
	// by passing it a WeaveletArgs with mtls=true.
	GetSelfCertificate(context.Context, *protos.GetSelfCertificateRequest) (*protos.GetSelfCertificateReply, error)
	// VerifyClientCertificate verifies the certificate chain presented by
	// a network client attempting to connect to the weavelet. It returns an
	// error if the network connection should not be established with the
	// client. Otherwise, it returns the list of weavelet components that the
	// client is authorized to invoke methods on.
	//
	// NOTE: This method is only called if mTLS was enabled for the weavelet,
	// by passing it a WeaveletArgs with mtls=true.
	VerifyClientCertificate(context.Context, *protos.VerifyClientCertificateRequest) (*protos.VerifyClientCertificateReply, error)
	// VerifyServerCertificate verifies the certificate chain presented by
	// the server the weavelet is attempting to connect to. It returns an
	// error iff the server identity doesn't match the identity of the specified
	// component.
	//
	// NOTE: This method is only called if mTLS was enabled for the weavelet,
	// by passing it a WeaveletArgs with mtls=true.
	VerifyServerCertificate(context.Context, *protos.VerifyServerCertificateRequest) (*protos.VerifyServerCertificateReply, error)
	// LogBatches handles a batch of log entries.
	LogBatch(context.Context, *protos.LogEntryBatch) (*emptypb.Empty, error)
	// HandleTraceSpans handles a set of trace spans.
	HandleTraceSpans(context.Context, *protos.TraceSpans) (*emptypb.Empty, error)
	mustEmbedUnimplementedDeployerControlGrpcServer()
}

// UnimplementedDeployerControlGrpcServer must be embedded to have forward compatible implementations.
type UnimplementedDeployerControlGrpcServer struct {
}

func (UnimplementedDeployerControlGrpcServer) ActivateComponent(context.Context, *protos.ActivateComponentRequest) (*protos.ActivateComponentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateComponent not implemented")
}
func (UnimplementedDeployerControlGrpcServer) GetListenerAddress(context.Context, *protos.GetListenerAddressRequest) (*protos.GetListenerAddressReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetListenerAddress not implemented")
}
func (UnimplementedDeployerControlGrpcServer) ExportListener(context.Context, *protos.ExportListenerRequest) (*protos.ExportListenerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportListener not implemented")
}
func (UnimplementedDeployerControlGrpcServer) GetSelfCertificate(context.Context, *protos.GetSelfCertificateRequest) (*protos.GetSelfCertificateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSelfCertificate not implemented")
}
func (UnimplementedDeployerControlGrpcServer) VerifyClientCertificate(context.Context, *protos.VerifyClientCertificateRequest) (*protos.VerifyClientCertificateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyClientCertificate not implemented")
}
func (UnimplementedDeployerControlGrpcServer) VerifyServerCertificate(context.Context, *protos.VerifyServerCertificateRequest) (*protos.VerifyServerCertificateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyServerCertificate not implemented")
}
func (UnimplementedDeployerControlGrpcServer) LogBatch(context.Context, *protos.LogEntryBatch) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogBatch not implemented")
}
func (UnimplementedDeployerControlGrpcServer) HandleTraceSpans(context.Context, *protos.TraceSpans) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleTraceSpans not implemented")
}
func (UnimplementedDeployerControlGrpcServer) mustEmbedUnimplementedDeployerControlGrpcServer() {}

// UnsafeDeployerControlGrpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeployerControlGrpcServer will
// result in compilation errors.
type UnsafeDeployerControlGrpcServer interface {
	mustEmbedUnimplementedDeployerControlGrpcServer()
}

func RegisterDeployerControlGrpcServer(s grpc.ServiceRegistrar, srv DeployerControlGrpcServer) {
	s.RegisterService(&DeployerControlGrpc_ServiceDesc, srv)
}

func _DeployerControlGrpc_ActivateComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.ActivateComponentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployerControlGrpcServer).ActivateComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeployerControlGrpc_ActivateComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployerControlGrpcServer).ActivateComponent(ctx, req.(*protos.ActivateComponentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployerControlGrpc_GetListenerAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.GetListenerAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployerControlGrpcServer).GetListenerAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeployerControlGrpc_GetListenerAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployerControlGrpcServer).GetListenerAddress(ctx, req.(*protos.GetListenerAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployerControlGrpc_ExportListener_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.ExportListenerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployerControlGrpcServer).ExportListener(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeployerControlGrpc_ExportListener_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployerControlGrpcServer).ExportListener(ctx, req.(*protos.ExportListenerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployerControlGrpc_GetSelfCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.GetSelfCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployerControlGrpcServer).GetSelfCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeployerControlGrpc_GetSelfCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployerControlGrpcServer).GetSelfCertificate(ctx, req.(*protos.GetSelfCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployerControlGrpc_VerifyClientCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.VerifyClientCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployerControlGrpcServer).VerifyClientCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeployerControlGrpc_VerifyClientCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployerControlGrpcServer).VerifyClientCertificate(ctx, req.(*protos.VerifyClientCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployerControlGrpc_VerifyServerCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.VerifyServerCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployerControlGrpcServer).VerifyServerCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeployerControlGrpc_VerifyServerCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployerControlGrpcServer).VerifyServerCertificate(ctx, req.(*protos.VerifyServerCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployerControlGrpc_LogBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.LogEntryBatch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployerControlGrpcServer).LogBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeployerControlGrpc_LogBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployerControlGrpcServer).LogBatch(ctx, req.(*protos.LogEntryBatch))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployerControlGrpc_HandleTraceSpans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protos.TraceSpans)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployerControlGrpcServer).HandleTraceSpans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeployerControlGrpc_HandleTraceSpans_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployerControlGrpcServer).HandleTraceSpans(ctx, req.(*protos.TraceSpans))
	}
	return interceptor(ctx, in, info, handler)
}

// DeployerControlGrpc_ServiceDesc is the grpc.ServiceDesc for DeployerControlGrpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeployerControlGrpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "control.DeployerControlGrpc",
	HandlerType: (*DeployerControlGrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ActivateComponent",
			Handler:    _DeployerControlGrpc_ActivateComponent_Handler,
		},
		{
			MethodName: "GetListenerAddress",
			Handler:    _DeployerControlGrpc_GetListenerAddress_Handler,
		},
		{
			MethodName: "ExportListener",
			Handler:    _DeployerControlGrpc_ExportListener_Handler,
		},
		{
			MethodName: "GetSelfCertificate",
			Handler:    _DeployerControlGrpc_GetSelfCertificate_Handler,
		},
		{
			MethodName: "VerifyClientCertificate",
			Handler:    _DeployerControlGrpc_VerifyClientCertificate_Handler,
		},
		{
			MethodName: "VerifyServerCertificate",
			Handler:    _DeployerControlGrpc_VerifyServerCertificate_Handler,
		},
		{
			MethodName: "LogBatch",
			Handler:    _DeployerControlGrpc_LogBatch_Handler,
		},
		{
			MethodName: "HandleTraceSpans",
			Handler:    _DeployerControlGrpc_HandleTraceSpans_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/controlgrpc/deployer.proto",
}
