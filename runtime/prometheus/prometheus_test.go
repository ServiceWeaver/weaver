// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package prometheus_test

import (
	"bytes"
	"regexp"
	"testing"

	"github.com/ServiceWeaver/weaver/runtime/metrics"
	imetrics "github.com/ServiceWeaver/weaver/runtime/prometheus"
	"github.com/ServiceWeaver/weaver/runtime/protos"
)

func TestTranslateMetricsToPrometheus(t *testing.T) {
	type testCase struct {
		name     string
		input    []*metrics.MetricSnapshot
		expected []string // Regular expressions that translated metrics must match
	}
	for _, c := range []testCase{
		{"empty", []*metrics.MetricSnapshot{}, []string{"# Metrics in Prometheus text format"}},
		{
			"single",
			[]*metrics.MetricSnapshot{
				{Id: 1, Name: "hello", Help: "foo", Type: protos.MetricType_COUNTER, Value: 100},
			},
			[]string{
				"HELP hello foo",
				"hello 100",
			},
		},
		{
			"multiple",
			[]*metrics.MetricSnapshot{
				{Id: 1, Name: "hello", Type: protos.MetricType_COUNTER, Value: 100},
				{Id: 2, Name: "world", Type: protos.MetricType_GAUGE, Value: 200},
			},
			[]string{
				"(?s)hello 100.*world 200\n", // hello must come before before world
			},
		},
		{
			"serviceweaver_metrics",
			[]*metrics.MetricSnapshot{
				{Id: 1, Name: "hello", Type: protos.MetricType_COUNTER, Value: 100},
				{Id: 3, Name: "serviceweaver_foo", Type: protos.MetricType_COUNTER, Value: 300},
			},
			[]string{
				`(?s)hello.*SERVICEWEAVER AUTOGENERATED.*serviceweaver_foo 300`, // Service Weaver metrics after user metrics
			},
		},
		{
			"labeled",
			[]*metrics.MetricSnapshot{
				{Id: 2, Name: "hello", Type: protos.MetricType_COUNTER,
					Labels: map[string]string{"K": `B"C`},
					Value:  200},
				{Id: 1, Name: "hello", Type: protos.MetricType_COUNTER,
					Labels: map[string]string{"K": "A"},
					Value:  100},
			},
			[]string{
				`(?s)hello\{K="A"\} 100.*hello\{K="B\\"C"\} 200`,
			},
		},
		{
			"serviceweaver_node_label",
			[]*metrics.MetricSnapshot{
				{Id: 1, Name: "hello", Type: protos.MetricType_COUNTER,
					Labels: map[string]string{"serviceweaver_node": `123456789ABCDEF`},
					Value:  100},
			},
			[]string{
				`hello\{serviceweaver_node="12345678"\} 100`,
			},
		},
		{
			"histogram",
			[]*metrics.MetricSnapshot{
				{Id: 1, Name: "hello", Type: protos.MetricType_HISTOGRAM,
					Value:  100,
					Bounds: []float64{20, 40},
					Counts: []uint64{4, 2, 0}},
			},
			[]string{
				`hello_bucket{le="20"} 4`,
				`hello_bucket{le="40"} 6`,
				`hello_bucket{le="\+Inf"} 6`,
				`hello_sum 100`,
				`hello_count 6`,
			},
		},
		{
			"histogram_labeled",
			[]*metrics.MetricSnapshot{
				{Id: 1, Name: "hello", Type: protos.MetricType_HISTOGRAM,
					Labels: map[string]string{"K": "A"},
					Value:  100,
					Bounds: []float64{20, 40},
					Counts: []uint64{4, 2, 0}},
				{Id: 2, Name: "hello", Type: protos.MetricType_HISTOGRAM,
					Labels: map[string]string{"K": "B"},
					Value:  120,
					Bounds: []float64{20, 40},
					Counts: []uint64{5, 2, 0}},
			},
			[]string{
				`hello_bucket{K="A",le="20"} 4`,
				`hello_bucket{K="A",le="40"} 6`,
				`hello_bucket{K="A",le="\+Inf"} 6`,
				`hello_sum{K="A"} 100`,
				`hello_count{K="A"} 6`,
				`hello_bucket{K="B",le="20"} 5`,
				`hello_bucket{K="B",le="40"} 7`,
				`hello_bucket{K="B",le="\+Inf"} 7`,
				`hello_sum{K="B"} 120`,
				`hello_count{K="B"} 7`,
			},
		},
	} {
		t.Run(c.name, func(t *testing.T) {
			var dst bytes.Buffer
			imetrics.TranslateMetricsToPrometheusTextFormat(&dst, c.input, "", "")
			got := dst.String()
			var missing []string
			for _, e := range c.expected {
				if !regexp.MustCompile(e).MatchString(got) {
					missing = append(missing, e)
				}
			}
			if len(missing) > 0 {
				t.Errorf("expected regexp %q missing in translation:\n%s", missing, got)
			}
		})
	}
}
