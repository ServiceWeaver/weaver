// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package weaver

import (
	"net"
	"sync"

	"github.com/ServiceWeaver/weaver/runtime/codegen"
	"go.opentelemetry.io/otel/trace"
)

// Glossary of component related types:
//  - codegen.Registration: information about an available component.
//    Created in code generated by "weaver generate".
//  - component: created when a component is first requested. Contains
//    a componentImpl if the component is local, a componentStub if it
//    is remote.
//  - componentImpl: created when a component is instantiated in this process.
//  - Instance: common interface implemented by all local component implementations.
//    Implemented by componentImpl.
//  - componentStub: proxies method calls to remote componentImpls.

// Instance is the interface implemented by all component implementations
// (by virtue of [weaver.Implements] being embedded inside the component implementation).
// An Instance for a particular component only exists in processes that are hosting
// that component.
type Instance interface {
	// Logger returns a logger that associates its log entries with this component.
	Logger() Logger

	// Listener returns a network listener with the given name that is suitable
	// for hosting an HTTP server.
	//
	// Name may be used by the Service Weaver framework to route client traffic to the
	// corresponding network listener. As such, listener names should follow the
	// DNS format for names.
	//
	// HTTP servers constructed using this listener are expected to perform health
	// checks on the reserved "/healthz" URL prefix. (Note that this URL prefix
	// is configured to never receive any user traffic.)
	//
	// If different processes in an application call Listener() multiple times
	// with the same listener name but different options, the options value from
	// one of those calls will be used when constructing the listener.
	//
	// TODO(mwhittaker): Return the address of the proxy somehow. Right now, if a
	// user specifies a LocalAddress like ":0", they don't have a way to know what
	// address the proxy is listening on.
	Listener(name string, options ListenerOptions) (*Listener, error)

	// rep is for internal use.
	rep() *component
}

// componentImpl is a fully instantiated Service Weaver component that is running locally on
// this process. If the component's method is invoked from the local process,
// a local stub is used; otherwise, a server stub is used.
type componentImpl struct {
	component  *component     // passed to component constructor
	impl       interface{}    // user implementation of component
	serverStub codegen.Server // handles calls from other processes
}

// componentStub is a stub to a component running remotely on a different process.
// A componentStub is not a component implementation. Rather, it's a stub that
// proxies method calls over the network to a remote process.
type componentStub struct {
	stub *stub // stub used to create clients
}

// component represents a Service Weaver component and all corresponding metadata.
type component struct {
	wlet      *weavelet             // read-only, once initialized
	info      *codegen.Registration // read-only, once initialized
	groupName string                // read-only, once initialized

	implInit sync.Once      // used to initialize impl, logger
	implErr  error          // non-nil if impl creation fails
	impl     *componentImpl // only ever non-nil if this component is local
	logger   Logger         // read-only after implInit.Do()
	tracer   trace.Tracer   // read-only after implInit.Do()

	stubInit sync.Once      // used to initialize stub
	stubErr  error          // non-nil if stub creation fails
	stub     *componentStub // only ever non-nil if this component is remote or routed
}

var _ Instance = &componentImpl{}

// Implements[T] is a type that can be embedded inside a component implementation
// struct to indicate that the struct implements a component of type T. E.g.,
// consider a Cache component.
//
//	type Cache interface {
//		Get(ctx context.Context, key string) (string, error)
//		Put(ctx context.Context, key, value string) error
//	}
//
// A concrete type that implements the Cache component will be marked as follows:
//
//	type lruCache struct {
//		weaver.Implements[Cache]
//		...
//	}
//
// Implements is embedded inside the component implementation, and therefore
// methods of Implements (as well as methods of [weaver.Instance]) are available
// as methods of the implementation type and can be invokded directly on an
// implementation type instance.
type Implements[T any] struct {
	*componentImpl
}

// setInstance is used during component initialization to fill Implements.component.
func (i *Implements[T]) setInstance(c *componentImpl) { i.componentImpl = c }

// A Listener is Service Weaver's implementation of a net.Listener.
//
// A Listener implements the net.Listener interface, so you can use a Listener
// wherever you use a net.Listener. For example,
//
//	func main() {
//	    root := weaver.Init(context.Background())
//	    lis, err := root.Listener("hello", weaver.ListenerOptions{})
//	    if err != nil {
//	        log.Fatal(err)
//	    }
//	    root.Logger().Info("Listener available at %v", lis)
//	    http.HandleFunc("/a", func(http.ResponseWriter, *http.Request) {...})
//	    http.HandleFunc("/b", func(http.ResponseWriter, *http.Request) {...})
//	    http.HandleFunc("/c", func(http.ResponseWriter, *http.Request) {...})
//	    http.Serve(lis, nil)
//	}
type Listener struct {
	net.Listener        // underlying listener
	proxyAddr    string // address of proxy that forwards to the listener
}

// String returns the address clients should dial to connect to the
// listener; this will be the proxy address if available, otherwise
// the <host>:<port> for this listener.
func (l *Listener) String() string {
	if l.proxyAddr != "" {
		return l.proxyAddr
	}
	return l.Addr().String()
}

// ProxyAddr returns the dialable address of the proxy that forwards traffic to
// this listener, or returns the empty string if there is no such proxy.
func (l *Listener) ProxyAddr() string {
	return l.proxyAddr
}

func (c *componentImpl) rep() *component { return c.component }

// Logger returns a logger that associates its log entries with this component.
func (c *componentImpl) Logger() Logger { return c.component.logger }

// Listener returns a network listener with the given name.
func (c *componentImpl) Listener(name string, options ListenerOptions) (*Listener, error) {
	return c.component.wlet.getListener(name, options)
}

// ListenerOptions specifies optional configuration for a listener.
type ListenerOptions struct {
	// LocalAddress will be used as the address where the listener is
	// created for local executions (i.e., for single, multi, and weavertest
	// deployments).
	//
	// The value must have the form :port or host:port, or it may
	// be the empty string, which is treated as ":0".
	//
	// If the port number is zero, an unused port number is picked.
	//
	// If the host portion is missing, the listener is bound to all
	// available addresses.
	//
	// Examples:
	//
	//	""                System picked port on all available addresses
	//	:0                System picked port on all available addresses
	//	:1234             Port 1234 on all available addresses
	//	localhost:1234    Port 1234 on loopback address
	//	example.com:1234  Port 1234 on external addresses for host
	LocalAddress string

	// dummy field to force users to use explicit field names
	useNamedFieldInitialization struct{} //nolint:unused
}

// WithRouter[T] is a type that can be embedded inside a component implementation
// struct to indicate that calls to a method M on the component must be routed according
// to the the value returned by T.M().
//
// # An Example
//
// For example, consider a Cache component that maintains an in-memory cache.
//
//	type Cache interface {
//	    Get(ctx context.Context, key string) (string, error)
//	    Put(ctx context.Context, key, value string) error
//	}
//
// We can create a router for the Cache component like this.
//
//	type cacheRouter struct{}
//	func (cacheRouter) Get(_ context.Context, key string) string { return key }
//	func (cacheRouter) Put(_ context.Context, key, value string) string { return key }
//
// To associate a router with its component, embed [weaver.WithRouter] in the component
// implementation.
//
//	type lruCache struct {
//		weaver.Implements[Cache]
//		weaver.WithRouter[cacheRouter]
//	}
//
// For every component method that needs to be routed (e.g., Get and Put), the
// associated router should implement an equivalent method (i.e., same name and
// argument types) whose return type is the routing key. When a component's
// routed method is invoked, its corresponding router method is invoked to
// produce a routing key. Method invocations that produce the same key are
// routed to the same replica.
//
// # Routing Keys
//
// A routing key can be any integer (e.g., int, int32), float (i.e. float32,
// float64), or string; or a struct where every field is an integer, float, or
// string (e.g., struct{x int; y string}). Every router method must return the
// same routing key type. The following, for example, is invalid:
//
//	// ERROR: Get returns a string, but Put returns an int.
//	func (cacheRouter) Get(_ context.Context, key string) string { return key }
//	func (cacheRouter) Put(_ context.Context, key, value string) int { return 42 }
//
// # Semantics
//
// NOTE that routing is done on a best-effort basis. Service Weaver will try to route
// method invocations with the same key to the same replica, but this is not
// guaranteed. As a corollary, you should never depend on routing for
// correctness. Only use routing to increase performance in the common case.
type WithRouter[T any] struct{}

// AutoMarshal is a type that can be embedded within a struct to indicate that
// "weaver generate" should generate serialization methods for the struct.
//
// Named struct types are not serializable by default. However, they can
// trivially be made serializable by embedding AutoMarshal. For example:
//
//	type Pair struct {
//	    weaver.AutoMarshal
//	    x, y int
//	}
//
// The AutoMarshal embedding instructs "weaver generate" to generate
// serialization methods for the struct, Pair in this example.
//
// Note, however, that AutoMarshal cannot magically make any type serializable.
// For example, "weaver generate" will raise an error for the following code
// because the NotSerializable struct is fundamentally not serializable.
//
//	// ERROR: NotSerializable cannot be made serializable.
//	type NotSerializable struct {
//	    weaver.AutoMarshal
//	    f func()   // functions are not serializable
//	    c chan int // chans are not serializable
//	}
type AutoMarshal struct{}

// TODO(mwhittaker): The following methods have AutoMarshal implement
// codegen.AutoMarshal. Alternatively, we could modify the code generator to
// ignore AutoMarshal during marshaling and unmarshaling.

func (AutoMarshal) WeaverMarshal(enc *codegen.Encoder)   {}
func (AutoMarshal) WeaverUnmarshal(dec *codegen.Decoder) {}

// WithConfig[T] is a type that can be embedded inside a component
// implementation. Service Weaver runtime will take per-component configuration
// information found in the application config file and use it
// to initialize the contents of T.
//
// For example: consider a cache component where the cache size should be configurable.
// Define a struct that includes the size, associate it with the component
// implementation, and use it inside the component methods.
//
//	type cacheConfig struct
//	    Size int
//	}
//
//	type cache struct {
//	    weaver.Implements[...]
//	    weaver.WithConfig[cacheConfig]
//	    ..
//	}
//
//	func (c *cache) Init(context.Context) error {
//	    ... use c.Config.Size ...
//	    return nil
//	}
//
// The application config file can specify these values as keys under the
// full component path.
//
//	["example.com/mypkg/MyComponent"]
//	Size = 1000
type WithConfig[T any] struct {
	config T
}

// Config returns the configuration information for the component that
// embeds this [weaver.WithConfig].
//
// Any fields in T that were not present in the application config
// file will have their default values.
//
// Any fields in the application config file that are not present in T
// will be flagged as an error at application startup.
func (wc *WithConfig[T]) Config() *T {
	return &wc.config
}
